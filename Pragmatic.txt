Lets start over with the Pragmatic Programmer

What Makes a Pragmatic Programmer?
    Early adopter/fast learner
    Inquisitive
    Critical Thinker
    Realistic
    Jack of all trades

Individual Pragmatists, Large Teams
    Don't ever stop learning

Chapter 1 (34)
    A Pragmatic Philosophy

    Try your best to understand the environment that you are working with and on. Many times you will find that the hardest thing to change is not the code but the mindset of the people that you will work with.

    The Cat Ate My Source Code
        Trust your team and be the person that you would want to rely on. 
        Remember that you should not only say something can or can't be done but be able to back up the claim.

    Software Entropy
        Remember that you will have Entropy no matter what happens when you have legacy software. Think about the broken window philosophy, many times the issue is that one small issue can make the issue far worse.

        Also remember that you should do no harm. Try to remember that issue that will come up and will make the end result far harder.

    Stone Soup and Boiled Frogs
        There is 2 ways to look at slow creep. One is that you are slowly adding more to a program by getting small increases.
        The other way is to see that boiling frog in water, the second is that you can and will accept more and more problems without seeing the issues.

        Both of these are continuing to do work while losing the big picture, these are not the issues of the Broken Window. At least here you are still in the game.

    Good Enough Software
        How great it would be to just know all the issues that will come up with any given 10% issue. We will not be able to see the issues before they come up, while also knowing that they will happen. Good enough can be good enough.

        Some of the best thing can be involving the user. Remember the user is the ultimate goal of any project. Many of the older projects have the Entropy of the past, but a new project can be a new start. Keep in mind you have the tools to change what needs to be changed.

        Also bear in mind that you must know when to stop tinkering and get to work. Don't get lost with bloat and lost the picture.

    Your Knowledge Portfolio
        Your knowledge of any given subject is an expiring asset. Don't stop trying to learn. Always try to learn something new every day/year.

        Invest Regularly
        Diversify
        Manage Risk
        Buy low, sell high
        Review and Rebalance

    Let's talk Goals
        Learn at least one new language every year
        Read a technical book each month
        Read nontechnical books
        Take classes
        Participate in local user groups and meetups
        Experiment with different environments
        Stay current

    Opportunities for Learning
        Even if you are doing all the above you still not know everything that person might ask of you. Remember that you might not know everything but knowing where to go to find the information is an important part of this.

        I think the hardest part of this will be to always be learning. Also be critical of what you read and hear, people will always be trying to sell you something. Beware of Zealots and hype. With that said here are 5 things to look out for.
            Ask the "Five Whys"
            Who does this benefit?
            What's the context?
            When or Where would this work?
            Why is this a problem?

    Communicate! English is just an other programming language
        You will get nowhere when you can't explain what you want or what you know.
        DRY and ETC

    Know Your Audience
        You must understand that not everyone has your exact level of knowledge. Either more or less try to understand what needs to be conveyed. Marketing just needs to know the features or time table. Many times it's about the feedback that you will receive from the people that you are trying to explain. Now that you know what they want make it happen.

    Choose Your Moment
        Although things have a time table that you might want to keep, when your bosses son is in the hospital might not be the best time to talk about a small new feature.

    Choose a Style
        Sometimes it's about the facts, sometimes its about the feeling, sometimes is about expressing the skill level that you have, sometimes it's about the tl;dr. Paragraph might or might not be the thing that you need to explain the issues.

    Make it look Good.
        Idea are great but they need a way to convey the message, 5 minutes right now can be the biggest factor or how a new feature will be implemented. There are many different ways to show a new project. 

        Sure Mermaid, or Livebook can be very helpful, but a white board and a marker can work just as well. Posits can be helpful to show the workflow or even allow you to change things easily. 
    
    Be a Listener
        As said before you must be willing to receive feedback and do something about it. What you say and what they say matters.

    Documentation
        Documentation can be important to avoid extra work. But keep in mind how you name variables and function can be their own form of documentation. There is an amazing lecture about understanding what you are building. A single function can be names well but in the grand scheme it makes no sense. Is it a function that simply adds or is it a function that combines different lists. One will say something that only a few would understand the other will help people understand the entire project.

Chapter 2 (73)
    A Pragmatic Approach
        Dry and Orthogonality are different approaches that pull from the same idea. 

    The Essence of Good Design
        Good design is easier to change than bad design. Keep ETC (Easier to Change) in mind. If you design with change in mind you can build more scalable and change tolerant code.

        Sometimes it's taking a time and thinking about a project before you start sometimes it's taking postit notes and building a map of the project. Either way its doesn't stop at the first line of code:
            Every save
            Every test
            Every bug fix 
        You need to think about tomorrow and the rest of the project. Baring in mind that you wont know the issues until you start a project and get the first issue or change that needs to be dealt with.

        Sometimes you have to write code with the idea that you are going to have to replace the code. That is where orthogonality comes in. How much does each line of code rely on an other. Can you just replace it with something or does everything fall apart when you do so.

        Think about using an editor to help you 
    
    Dry- The Evils of Duplication
        Many of the things that we do today is maintaining code not always code new lines. Maintenance doesn't start once we deploy, it starts at the beginning. NEw requirements come every day, even during development. Try always to not to repeat yourself, even my Blog has many instances of repetition. Did I really need the index 3 times?

        Also the Header that I had on every page... Use the root and have it everywhere.

    Dry Is More Than Code
        Not copying the same line of code everywhere is just a PART of DRY. DRY is about the duplication of knowledge, of intent. It’s about expressing the same thing in two different places, possibly in two totally different ways.

        Looking at the code in the example we see that we can put into a function the negative or positive sign, the label for each line, and the amount of space for each line. Now we only have to change a function to change the output. Thinking in this way will allow us to change small or large portions of the code in quick and easy ways.

    Not All Code Duplication is Knowledge Duplication.
        So in the case of the AGE/AMOUNT code. Its not a violation of DRY because its doing different things. Think back to the lecture about naming and what a function does. Although it might feel that way we will have issue if we now need to be sure that a customer only buys cases. This is a coincidence not duplication

    Duplication in Documentation

        For the fees code you should be able to read the code and see what the function does. Documentation here would be over kill as long as you describe the function and the lines appropriately. 

    Dry violation in Data
        Sometimes we need to have a value in a struct that is a combination of pervious fields. It might make more sense in this case to have the field be a function not just a field. Many times its best to set some private function to take care of those issues, that way you can change again just a small amount or add in the functions you need in order to accomplish what you want.

    Representational Duplication    
        Remember that you can use DRY as much as you want in personal code that might even see the light of day. But in code that will need to use API's and that will be seen it might be best to add more duplication to help a person on the other side better understand the code you are trying to impart. 
            Duplication Across Internal API'S  
                Try to have a central repository for all the API's
            Duplication Across External API's
                Many times public API's are documented with a OpenAPI tool that will allow you to import the documentation with ease.
            Duplication with Data Sources
                So you can always just use the Schema that the API will send, however it might help to send it into a self made Map/Key to allow you to better work with the data. It might not always work and you might find that you are missing a key part of the data but it might make things far easier to validate.
            
    Interdeveloper Duplication
        This might be the hardest DRY to maintain as with a large group of developers you will find that you are making the same thing over and over with small variations. The best an easiest way to deal with this is constant communication, and public documentation. That way you can at least stop yourself from doing the same thing your co-worker is doing. 

    Orthogonality
        This is a way to signal a independence or decoupling of code. You want to be able to change any part of code or a structure while doing the least damage to the rest of the project.

        Remember the Helicopter and you will do fine. Everything will have an effect on the other parts, but understanding that you can effect the amount of effect a change will do from the beginning will help a lot.
    
    Benefits of Orthogonality
        Keep in mind that for every function that will be called by an other anything that you change that effect the external will need to be dealt with by all other functions, but internal changes can be changed with little to no effect on the system. So doing everything you can to code Orthogonality will have benefits:
            Gain Productivity
                You can test and work on Orthogonal code way easier than things that are highly dependent. Having a function do x thing and a function that does y things can be combined into a single function that does x + y things if they are truly Orthogonal.
            Reduce Risk
                If you have an issue with a section of code you will not effect the rest of your code. The system also becomes less fragile. You will have better test environments. You will also be less tied to a specific vender as you can simply remove that section of code a write a new one that doesn't rely on that vender.
        
    Design
        Design can be a way to start off a project with Orthogonality in mind. Many times its best to think in terms of layers, this works because each layer adds its own abstraction to the code and "hopefully" you only need to change the 1 layer in order to effect the change that you want.

        Also keep in mind that even the data you store about your customer or the user name that you use for a data entry can be dependent. Ie a phone number might seem like a good choice, on repeatable etc, what happens when the phone number change and you now need to augment many relational databases. That is where those entries can exist but should not be the sole identifier for any given customer.

    Toolkits and Libraries
        Always be wary of a new library or even other members of your team. Can the new library be added without layers of abstraction? Can you change the output to fit your needs without adding new methods? Then the new library is Orthogonal.
    
    Coding
        Every time you add code you run the risk of reducing Orthogonality here are some techniques to help you maintain:
            Keep your code decoupled
            Avoid global data
            Avoid similar functions

    Testing
        Remember that any interaction between any systems should be limited and formalized. This will help make your system easier to test. You can set some basic test for each component and then test them together. You can even formalized the test for combined elements.

    Documentation
        Same with the rest of your code think Orthogonal with even your documentation.

    Living with Orthogonality
        While DRY is avoiding duplication Orthogonality is reducing dependency between elements or Libraries.

        Exercise 1 
            I think that the hardest part here is understanding that you want as much decoupling as possible, If you see example 1 y0ou think it has all the parts but its all 1 class, where any change to the reader will involve changing the entire class. 2 has less in the one class but you have less to change to the class definition.

        Exercise 2
            While OO languages can still be DRY or Orthogonal adding in sub classes and overriding you will find it becomes harder and harder to decouple each new feature.
            The hardest part of functional languages is that each small function can be Orthogonal but when the data needs to be constantly mutated you will run into an issue if your lowest layer needs a change that will propagate to the rest of the functions
    
    Reversibility
        One of the hardest things to comprehend is that things can change and you might not have the ability to keep the code you are currently working on. This becomes a big hassle when you myst change vendors or a library goes out of updates.

        Decoupling can be super helpful when things change in development. Is it going from a html to an APP? Did the third-party product company go out of business? If you plan on using the vender as little as possible and abstract out all the calls you can do yourself a huge favor and allow changes to happen organically.

    Flexible Architecture 
        One thing to do is to keep all third-party API's behind your own layers. If you change API's you will have an infrastructure pulled out with all the data you need in a single place.

    Tracer Bullets
        Tracer bullets are rounds that will leave a trail so in high stress environments you can know if your tracer bullets are hitting so are your regular bullets. How can we do this in programming?

    Code that glows in the Dark
        You want to start with the things that will be of the most importance to the project. That way you aren't spending all the time working on a small feature that may never see the light of day because of changes to the UI or time constants. 

        Sometimes a tracer code is getting it compiled and printing "hello world"

        Here are some of the advantages of tracer code:
            Users get to see something working Early
            Developers build with structure in mind
            You have an Integration platform
            You have something to demonstrate
            You have a better feel for the progress

    Tracer bullets don't always hit their target
        Remember that you wont always hit your target with tracer bullets. That is the point!! use the feedback to change where your are targeting. Every update and change should try to bring you closer to the target. If you didn't have the tracer rounds you might never see how far you are off.

    Tracer Code Versus Prototyping
        Prototyping might get completely thrown away once the proof of concept is show. Tracer Rounds are for the entire lifecycle of the project. 

        Not to say that Prototyping isn't useful it truly is, you will need to prototype a new packing algorithm, or prototype a new UI for the system you will implement. 

        Remember that; Prototyping generates disposable code, Tracer code is lean but complete.

    Prototypes and Post-it Notes
        Remember that a Prototypes is designed to test a single or VERY FEW things. We so don't create a prototype to test an entire end result. Tracer rounds would be better for this but even that is not the best here.

        This is where the idea of "other types of materials" would come in. Maybe its a post-it board where you discus the workflow, maybe its a simple html template on a few site that allows for things to be added easily. This helps too as you can ignore unimportant data (for now) for as long as you are prototyping.

        Just bare in mind that if you find a lot of important details that can't be missed or you find you want to test too many things a Tracer Bullet style might be best.

    Prototype to learn
        What should we prototype ignore for a prototype?
            Correctness
            COmpleteness
            Robustness
            Style

            Remember that you are testing for very specific things not just trying to build out a full production level code.

    Prototyping Architecture
        Architecture is one of the easiest things to Prototype as you are building the way the different aspects of your program will interact. Whiteboard and post-its, Pen and paper. Here are some things to think about when you are looking to prototype:
            Are the responsibilities well defined?
            Are the collaborations between components well defined?
            Can you identify sources of duplication?
            Are interface definitions and constraints acceptable?
            Do you have an access path to the data if/when you need it?

    How Not to Use Prototypes
        The biggest thing to take from this is that if you are building a prototype you are building DISPOSABLE CODE. You are not trying to finish a project but figure out the potential issues that might come up and show a proof of concept. Try you absolute best to instil the idea that this code will be thrown out. 

        Make sure that the higher ups are realistic about the end result and steer then to the Tracer Bullet style if they insist.

        Exercise 3
            Pen and paper for the win here, maybe add in some post-it notes as you might want to change some of the locations. Try to get different sized post-it notes so that you can make things more dynamic.

    Domain languages
        So we think in the language that we learn at birth and we program in the language that we are building in. You need to understand these differences and build with them.

    Some Real World Domain languages
        Rspec
            Testing lib for Ruby
        Cucumber
            Is a programming-language neutral tester and you import the syntax as needed for the language that you need.
        Phoenix Routes 
            Way of dealing with HTTP requests (GREAT!!!)
        Ansible
            Written in YAML and is a set of tools to configure software usually on a bunch of remote servers.
    
    Characteristics of Domain Languages
        There will be internal (RSpec Phoenix) and external (Ansible Cucumber).
    
    Trade-offs between Internal and External Languages.
        Internal will have many built-in features and will come at not extra cost. But it comes at the cost of having to be completely within the syntax of the mother language.

        External languages do not have the issue, you just need a parser. They can be hard to write on their own but once you have them you can build many test with ease. Check out:
            bison
            ANTLR
            PEG 
        
        The thing to remember about external languages is that you should not spend more time than you would save by just building your own INTERNAL tests.

        Exercise 4, 5
            typedef struct {
            char cmd; /* the command letter */
            int hasArg; /* does it take an argument */
            void (*func)(int, int); /* routine to call */
            } Command;
            static Command cmds[] = {
            { 'P', ARG, doSelectPen },
            { 'U', NO_ARG, doPenUp },
            { 'D', NO_ARG, doPenDown },
            { 'N', ARG, doPenDir },
            { 'E', ARG, doPenDir },
            { 'S', ARG, doPenDir },
            { 'W', ARG, doPenDir }
            };

        Exercise 6
            <time> ::= <hour> [":" <minutes>] <ampm>
            <hour> ::= <h10digit><digit>
            <minutes> ::= <m10digit><digit>
            <h10digit> ::= "" | "1" | "2"
            <m10digit> ::= "1" | "2" | "3" | "4" | "5" | "0"
            <digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
            <ampm> ::= "am" | "pm"

        Exercise 7
            defmodule TimeParser do
            import NimbleParsec

            digit = ascii_char([?0..?9])

            hour =
                choice([
                string("23"),
                string("22"),
                string("21"),
                string("20"),
                string("19"),
                string("18"),
                string("17"),
                string("16"),
                string("15"),
                string("14"),
                string("13"),
                string("12"),
                string("11"),
                string("10"),
                times(digit, max: 2)
                ])

            minutes = times(digit, 2)
            ampm = choice([string("am"), string("pm")])

            defparsec(
                :time,
                hour
                |> optional(ignore(string(":")))
                |> optional(minutes)
                |> optional(ampm)
            )

            def convert({:ok, list, "", _, _, _}), do: convert_time(list)
            def convert({:ok, _, _, _, _, _}), do: "error: bad time syntax"

            defp convert_time([hour]) do
                %{minutes_past_midnight: time_conversion(String.to_integer(hour), 0, "")}
            end

            defp convert_time([hour, ampm]) do
                %{minutes_past_midnight: time_conversion(String.to_integer(hour), 0, ampm)}
            end

            defp convert_time([hour, ten_min, min]) do
                %{
                minutes_past_midnight:
                    time_conversion(String.to_integer(hour), 10 * (ten_min - 48) + (min - 48), "")
                }
            end

            defp convert_time([hour, ten_min, min, ampm]) do
                %{
                minutes_past_midnight:
                    time_conversion(String.to_integer(hour), 10 * (ten_min - 48) + (min - 48), ampm)
                }
            end

            defp time_conversion(12, minutes, "am"), do: minutes
            defp time_conversion(hour, minutes, "pm") when hour != 12, do: (hour + 12) * 60 + minutes
            defp time_conversion(hour, minutes, _), do: hour * 60 + minutes
            end

            TimeParser.convert(TimeParser.time("12"))

    Estimating
        Estimation is the essence of delivering information without doing all the mathematics or building an entire program. Its important for getting a mostly accurate time line as well as whether or not the desired result can even be done.

    How Accurate is Accurate Enough?
        The units that you use can matter far more than the precision of the information that you are trying to convey. Think about deadlines in these time frames
            1-15 days       days
            2-6 weeks       weeks
            8-20 weeks      months
            20+ weeks       really think about giving an estimate.

    Where do Estimates come from?
        Try to remember that you can always ask someone that has already done it before, other people or forums can be super helpful when trying to learn how to estimate.

            Understand what is being asked
                Do you need to tell them every little detail. Is it assumed that, "when will you be here?" is assuming that there is no traffic?
            Build a model of the system
                This doesn't have to be an actual model, this can just be a mental model. This will help you start to work out kinks in the system. Use this time to work out the Parameters and what can be dropped
            Give each Parameter a Value
                This is where you work on the data points and the most important parts of the system. Remember that you can spend tons of time working on a very small and unimportant part of a project and let the important parts be lost.
            Calculate Answers
                This is one of the things that come with time. When you first start a project you might say with confidence that it will take 3 weeks. Later in the cycle of the project or your career you will find that there is nuance to the answer. Is your team learning a new Lib. is it Christmas week. What are the system speciations? These are questions that might lead you to change the precision of the answer or the time frame.
            Keep track of your estimating prowess
                When you are spot on remember it. When you are off remember it and find out why.
    
    Estimating Project Schedules.
        Many times people don't estimate with a single number but multiple time frames with different reasons why. There will be times that a customer or boss will just want the worst case and you should be able to deliver that.

        PERT (Program Evaluation Review Technique): This method will allow you to use a range of values to avoid just padding the estimate because you are unsure.

        Eating the Elephant: 
            Check Requirements
            Analyze Risk (do riskiest items first)
            Design, implement, integrate
            Validate with the users
        
            Once you have started the process take time to reevaluate the time table and adjust
        
    What to say When Asked for an Estimates
        "I'll get back to you."

        Exercise 9
            This depends on a few things but in the end you might be able to get more out of the flash drive. With zero time to access the storage device and perfect mouse movement you can get far more out of the device...

            What happens when you can run this 1Gbps connection overnight? Will the person be able to perfectly access and copy everything needed> can every item be split properly?

        Exercise 10
            Depending on the time frame and size of the files I would say the person should win.

Chapter 3 The Basic Tools 
    Always be on the lookout for better tools. You might start out with some brand new tools and they will form to your hands and mind. But that doesn't mean that you will not find new and different tools for the same job.

    Don't get compliant with your current set of tools, you might get very used to it but in the end do you want years of knowledge or the same knowledge over and over again.

    The Power of Plain Text
        You will be using your Knowledge as the wood you will build your projects with. 

    What is Plain Text?
        It is the set of printable characters that conveys information. Keep knowledge in plain text.
    
    The Power of Text
        This ensures a few things.
            Insurance against Obsolescence: Human readable text is very important for the future. There is a catch if you have sensitive data but simply making sure that only those that need the data can help. You should code for readability.
            Leverage existing tools: You might need to be sure that any new lib or project in under version control. This will help you maintain any changes and keep the project under control.
            Easier testing: Test in plain text are a lot easier to change/add without having to change any existing tests.

    Lowest Common Denominator
        No matter where we are in the future the plain text will still exist to help those with a readme etc.

    Shell Games
        Don't get stuck in one way of doing things, Shell can help you do so many things, like automate many of the trivial tasks. GUI interfaces are nice and have many built-in tools but cannot have the automation of a Shell used correctly.

    A Shell of your Own
        You should be able to fully customize the environment of the shell you are working with.
            Setting color theme
            Configuring the prompt
            Aliases and Shell functions
                alias apt-up='sudo apt-get update && sudo apt-get upgrade'
            Command Completion
        
        Be a hermit crab and make the Shell your own home.

    Power Editing   
        You don't have to be a slave to a certain editor but you should try to familiarize yourself with all the built in functionality of the editor. You want to stop thinking about how to use the editor and start to just let the commands flow from you. Yes you'll save time but you want your editor to be a well used tool that you know where the cut will happen.

    What Does "Fluent" Mean?
        When editing text, move and make selections by character, word, line, and paragraph.
        When editing code, move by various syntactic units (matching delimiters, functions, modules, …).
        Re-indent code following changes.
        Comment and uncomment blocks of code with a single command.
        Undo and redo changes.
        Split the editor window into multiple panels, and navigate between them.
        Navigate to a particular line number.
        Sort selected lines.
        Search for both strings and regular expressions, and repeat previous searches.
        Temporarily create multiple cursors based on a selection or on a pattern match, and edit the text at each in parallel. ctrl + alt + down/up and then ctrl + right to get to the end of the word
        Display compilation errors in the current project.
        Run the current project’s tests.

        **test** boom
        **here** boom
        **please** boom

    Moving Toward Fluency
        Every time you do something repetitively think about how you might automate that, at least write it down. That way you can ask a friend or coworker about tips that they use etc.

    Growing with your Editor
        Every time you think that you are at the end of usefulness for your editor search for an extension. I bet there is an extension for that editor to do want you want. You should stop doing autorepeat and learn the commands for going back one word etc.

    Version Control
        This is a big one and you have already started to work on this with Github.

    It starts at the Source
        It's not just about an undo button it's about answering real questions about the system as it changes. Who changed what? What are the differences between 2 lines of code or branches. It also allows more than one person to work on any given project.

    Branching Out
        Think of branches as little cloned projects. That way you can not only keep new features separate but you can see the entire chain of thought that led to each decision. This will help you to pick an choose what you add and help keep things Orthogonal and DRY. Try to implement every new feature as a separate entity.

    Debugging
        This is an integral part of any codes lifecycle. You must deal with issues as they come up

    Psychology of Debugging
        Fix the problem, Not the blame
        Don't panic
        Don't say that's impossible
        Know where to start
        Always gather as much information as possible 
        Leave your ego at the door.

    Debugging Strategies
        Reproduce the bug - try to reduce the obfuscation and get right to the issue , if you can isolate the bug you might find out a lot more about what is the issue.
        Read the Damn Error message.
        Many times just looking at one aspect of the error and lead you down the wrong rabbit hole. It might be helpful to open up a debugger and keep the result and the code open at the some time. It might just be that .0045 is 4.5 in the code etc.

        There might be times that you will get to production and then the code breaks, you might run straight to the code and see what is "wrong" but you also might have bad data.

    The Binary Chop
        Its not just searching through the entire array starting at the top. You want to divide and conquer. How can we apply this to coding and debugging.

        CHoose a stack frame and then see if the issue is before or after. Remember that if the size is 64 you will find it within 6 attempts if you can determine simple before/after an event.

    Logging and/or Tracing
        Tracing statements are the IO.inspect("I got here"). This can be done in the code or the log file with a search. You want to find out with as much ease as possible.

    Rubber Ducking
        This is as simple as asking someone what they thing while explaining the problem, maybe even have then over your shoulder. You can even rubber duck yourself.

    Process of Elimination.
        Always start with your own code before trying to blame a third part or other developer. You might think that your code is rock solid but odds are that new and developing code will be the problem 90% of the time. Remember that if you see horse prints think horse not Zebra. The thing that "just" changed and broke the system is likely to be the problem. 

    The Element of Surprise
        This is the thing that will hold many back. They surprise when the thing that they knew was never going to be an issue is. The amount of surprise you have when a system goes down is proportional to the faith you had in the system. Don't assume it Prove it. Why wasn't the bug caught earlier? Can you figure out why the bad data wasn't caught earlier? Can you fix any other issues while you found the issue with the case you are just fixed?

        Debugging Checklist
            Is the problem a direct result of an underlying bug?
            IS the bug really in the framework, Your code? OS?
            How would you explain this bug to a co-worker?
            Are your unit test complete enough?
            Does the exact condition that lead to the bug in any other part of the system?

    Text Manipulating
        Learn a Text Manipulation Language
            Building the Book
            Code inclusion and highlighting
            Website update
            Including equations
            Index generation

        Exercise 11
            Check out the file camelCases.exs  
        Exercise 12
            Check out the file camelCases.exs 
        Exercise 13
            Check out the file camelCases.exs 

    Engineering Daybooks
        Thing about this as a daily log of what you are doing. Many times its not about rereading the text as much as it is putting things down so you will remember them better.
            Better than memory.
            Gives you a place to store and Idea without needing to remember it later.
            You can also use it as a Rubber Duck to talk to.

Chapter 4 Pragmatic Paranoia (188)
    You Can’t Write Perfect Software. You should try to code defensively keeping in mind that you can't control others software and you will need to validate anything we are given and make ourselves. 

    Design by Contract
        Rights and responsibilities, as well as defining what happens when you don't come through or fail. This is where DBC comes in. Does your programming do exactly what you said it should do, no more no less? Let's talk about the expectations and claims that a program should have:
            Preconditions: what should be given to the function
            Postconditions what the function so produce
            Class invariants Things can go wrong in the process but must be correct once you are taken out of the function.

        When you have your contract you will be able to see who or what is not living up to the contract. Is the output wrong? Was it the Predata, the function? Some languages can more easily deal with the idea of pre and post data.

        Class invariants and Functional languages
            This can be more about state than the "class" as we pass a state from one function to an other.
        
        Implementing DBC
            Documenting the assumptions can be a great start but you can not automate the entire process.

            The idea of crash early will help you understand what is happening under the hood that might be a problem. Remember that Elixir can use Guards to at least set the Preconditions. Things that help with understanding the conditions that triggered an error will help.

        Semantic invariants
            When you find a requirement that qualifies make it part of your documentation and production. Try also to make it concise.

            Exercise 14
                Doc """
                getSpeed > 0 
                    implies isFull
                getSpeed >=0 && 
                getSpeed < 10
                """
                boolean isFull()
                int getSpeed()
                Doc """
                @pre abs(getSpeed - x) <= 1
                @pre x > 10 && x >= 1
                @post getSpeed == x
                ""
                void setSpeed(int x) when x > x -1 or x < x + 1
                @doc """ 
                @pre !isFull()
                @post isFull()
                """
                void fill()
                @doc """
                @pre isFull
                @post !isFull
                """
                void empty()

    Dead Programmers Tell no Lies
        Most every case should have a default that is not always in the defined input so we know when the impossible happens.

        Catch and release is for Fish
            You might get more out of propagating the error that way you can see the issue sooner than if you were to always find a bunch of predetermined errors. 
            
            In elixir there is built-in error handling with Supervisors that way if an error happens we can log it and restart the child. We want this as if you find a way to keep it running we might send bad data into a DB that we don't want to see.

    Assertive programming
        We must not fall to the mantra that "This can never happen" this will lead you to do things lazily or miss key thing to think about when a Program fails.

        This is done in many languages with asserts. If you know that a return value should never be nil check for that. This is not a thing to use in handling real errors that will need to be part of the code. These are test that will help you better understand the code.

        Also don't rely on any test or data that is from an assertion. Real life data will never act the same way.

        Assertions and Side Effects
            Make sure that you realize that an assertion can move and index or change a variable when its being checked. You want to keep the assertions turned on as much as possible. This is the case for 2 reasons:
                Tests don't find all the bugs.
                Your real will do things to your code that the test environment will never experience.

            Exercise 16
                Everyone of of these things can happen that is the point of the exercise. Think about why they might happen, mod, leap seconds and months, non-Euclidean Geometry etc.

    How to Balance Recourses
        Finish what you start. Be very wary of a function not finishing what it started. If you need to read and write to a file do both in one function. Will you always remember to close a file after opening it? You cant even just add an extra case to this as you will find that more and more of the code will be coupled. Finish what you start. 

        Create a new function that will call read the function do the work and then close no matter what. There might be a way to create a block that any file or resource is allowed to be open in. Either way start to think locally.

        Try to also remember that even logs create and use space to deal with them. Is there a built-in way to clean them up? Do you need to make one?

        Nest Allocations
            2 way to deal with more than 1 resource being needed for a function:
                Deallocate in reverse order
                Alway allocate the resources in the same order no matter where you use them. At least then you can have the same way of giving them back and wont run into issues later.
        
        Objects and Exceptions
            OOP can be helpful if you create classes for every new object. That way a garbage collector will deal with it once the object or class is no longer needed.

        Balancing and Exceptions 
            You might have have some issues with resource allocation and deallocation when you deal with exceptions. 

            Some languages have a try, catch, and finally that will run at the end of the scope or the function. This might feel like a perfect thing to deal with any deallocation, but what if the entire function isn't run? 

            The better way of using this might be to allocate the resource then do your begin and then finally that way no matter what we run the allocate and the deallocate.  

        When you can't balance Resources
            Think about how most allocation of resources works, it will stay in memory until the scope is no longer needed. What if the top layer of the program needs a resource intermittently? Here are some options:
                Top level is responsible for any deallocations and recursively will deallocate
                Top level is deallocated and then all needed resources are orphaned
                Top level will never deallocate if it has any active resources
            
            Always make wrappers to check the balance of any state or resource needed. YOu might have a top layer that will wait for any input this might be a great place to create and use your wrappers to deal with any issues.

            Exercise 17
                You will never have an issue with the pointer going to erroneous data.

            Exercise 18
                You want an object variable to be set to 1 because every time you remove a reference you remove a pointer to an object once you have 0 pointers to an object it can't be collected.
        
    Don't Outrun your headlights
        This isn't a reference to the ability to go faster than the speed of sound but a reference to the idea of going faster than you can react or make sense of the information you are getting.

        Take Small Steps Always
            Only take steps that you can receive feedback for or for an action that can be proven. Only do things that can be done without fortune telling:
                Completion date months in the future
                Plan for future Maintenance
                Guess users future needs
                Guess future tech availability

        You might think that we always want to code for the future well this can be helpful but coding for replacement is better. You can't predict the future and the first black swan was an anomaly that no one could have foreseen.

Chapter 5 Bend, or Break
    Decoupling
      Bare in mind the coupling is the enemy of change. Will you decouple or try to track down every coupling so that you can make every change needed when you change a function. Compare that with links and you will see that small things can change without the entire structure needing to change. Here are some things to think about:
        Train wrecks - chains of method calls
        Globalization - dangers of static things
        Inheritance - Why subclassify is dangerous 
    
        Train wrecks
            Try to tell don't ask. The example takes a lot of information and then does work on it. Also what is the function trying to do? We should only get the info that we need and try to keep as much behind the scenes so to speak. It went from get customer/ get all orders/ find the right order/ get total/ add discount/ change discount to;
            get order by id/ apply discount

        Law of Demeter (for a class C)
            Other instances methods in C
            It's parameters
            Methods in objects that it creates
            Global Variables

        Don't Chain Methods (the 1 dot rule)
             
        The Evils of Globalization
            Global data can be very harmful as it adds an extra parameter to every function. Tests are the biggest thing to worry about with global data as with every test you will need to setup the global data to get to a proper test environment. 

            Even if you write a singleton (IE one instance of the class) it can still be Global Data, at least try and set the variables and then set a function within the class to access the data.

            Remember this all boils down to change the less coupling the better.

    Juggling the Real World
        What is an event? Its the availability of information. Let's look at strategies for writing code the handles based on events. 
            Finite State machines
            The Observer Pattern
            Publish/Subscribe
            Reactive Programming and Streams

        Finite state machines can be very helpful to deal environments as you can transition between different states and each state might only have a few lines of code for each state.

        Here are some other ways to process events
            The Observer Pattern
                In this way of doing things we have the a source of events (observable) and a list of clients (observers).  An observer registers its interest with the observable. This is more of a way for a server to notify all the observers. Like in the Terminator module in Ruby, it will terminate the application and as such will need to notify all the observers.

            Pub/Sub
                You've seen this before in the Elixir course work you have publishers and Subscribers that will need to be notified off all the changes. THis is helpful as not every change to the system needs to be sent to every user at all times. This also help to do things asynchronously.  What is also nice is that most cloud based servers offer some from of this automatically. 

                The down side is that a lot of the work is done behind the scenes and you might not be able to diagnose the issue as easily. 

            Reactive PRogramming, Streams and Events
                Just like excel spread sheets any cell that refers to an other cell is a reactive cell. Streams can help with this is they are passed the relevant info. What is nice about streams is that we can do things as the data comes in and if we zip 2 streams we can wait for both sides to have info before we do anything. Combine with a timer stream and you can update every x seconds.

            Exercise 19
                class FSM
                    def initialize(transitions, initial_state)
                        @transitions = transitions
                        @state = initial_state
                    end
                    def accept(event)
                        @state, action = TRANSITIONS[@state][event] ||
                TRANSITIONS[@state][:default]
                    end
                end
            
            Exercise 20
                Many of these would use PubSub and Streams
    Transforming Programming
        Don't get caught up in thinking just about code try and remember that everything you do is taking an input and sending an output. 

        Let's gp back in time to the 70's we want to find the longest file in file structure
            $ find . -type f | xargs wc -l | sort -n | tail -5 *| head -5*
                find . -type f
                Write a list of all the files (-type f) in or below the current
                directory (.) to standard output.
                xargs wc -l
                Read lines from standard input and arrange for them all
                to be passed as arguments to the command wc -l. The wc
                program with the -l option counts the number of lines in
                each of its arguments and writes each result as “count
                filename” to standard output.
                sort -n
                Sort standard input assuming each line starts with a
                number (-n), writing the result to standard output.
                tail -5
                Read standard input and write just the last five lines to
                standard output.
        Finding transformations
            It's input to output say you want to get a set of letters and output the words that can be made from them. 
                input
                combination of 3 or more letters
                signature of the combinations
                list all that match a given dictionary
                Group words by length

            We can then break down each step, here is step 1:
                input
                convert to characters
                get all subsets
                only those longer than 3
                convert back to strings

            What is the |> operator?
                What is nice about |> is that you start to think about everything as a transformation of a value. 

                Many languages have something similar: Elm, F#, and Swift have |>, Clojure has -> and ->> (which work a little differently), R has %>%. Haskell both has pipe operators and makes it easy to declare new ones. As we write this, there’s talk of adding |> to JavaScript.

            Step2
                Now we need to transfrom the subsets into signatures. 
            
            Step3
                Map signatures to a list of words

            Step4
                Group by length
            
            All together
                Now we just need to put it all together, calling each function in turn. This is great as any step can be modified as long as we remember what goes into and out of each function.
            
            This also helps us think about not hording data and jsut think about data -> code -> data -> code ... we can then reduce coupling. Add in type checking and you will find that most every change should be found before you go to execute the program. 

            We can handle error handling a little differently when we are passing data bewteen states. If you just pass raw datat you will have issues with not knowing what kind of state the data is in. 

            Elixir doesn't have any built-in way of doing this but the {:error/:ok, data can work well}

            A nice way way to making sure that we only go on to the next line is to use Patern Matching for every function. So we can only do:

            def funciton({:ok, data}, other params...) so that way we will not find an implementation for the given data and pass an error. Or even add a case for the error condition.

            What is there to be sure that we only pipe to functions that can do the result?
                and_then(value \\ {:ok, value}, func) do, func(value)
                def and_then(anything_else, _func), do: anything_else

                This is used to be sure that each part of the function will only accept the right value that we send in the right form. I have value as a place holder and we would want it to be a tuple of some kind.

            Exercise 21
                An order ({:ok, order})
                |> add_sales_tax() {:ok. order(with sales tax added)}
                |> add_shipping() {:ok, order(with shipping added)}

                A file {:ok, file}
                |> open/close_file() {:ok, lines from the file}
                |> get_settings() {:ok, settings from the file as a map}

                User {:ok, map with name and pass}
                |> sign_in() {:ok, user okay}

            Exercise 22
                validate_and_convert(string) when is_string(string) do
                    integer = to_integer(string)
                    cond do
                        integer > 18 and integer < 150 -> {:ok, integer}
                        integer >= 150 -> {:error, "greater than 150"}
                        integer <= 18 -> {:error, "less than 18}
                    end
                end
            
            Exercise 23
                We ofc prefer the first as it's less coupled. The entire second code replies on the fact that each function will use the results of an other function, there is less error handling in any of that second code.

    Inheritance Tax
        Don't use Inheritance to avoid typing or because you simply like types. These things can and will add to coupling. You change one thing and everything after becomes a lot harder to change. 

        Even if it's jsut setting types we can run into an issue with things not beign well defined or even worse to well defined and not knowing where everthing should go. You can't set everything into a category, once you do you will then need a lot of categories or need a very large category. 

        Think about it this way, a car might be a vehicel, but it's also an: asset, a payment, Loan Collateral, etc. 

        Let's talk ways to avoid Inheritance:
            Interfaces and protocols
                So once we set the implement we can then be sure that we know which protocol we need, Then we set the type for the one being called in the language we are using. So a Car might have Drivable and Locatable, But a Phone might be Locatable as well. We then say that:
                    List<Locatable> items = new ArrayList<>();
                    items.add(new Car(...));
                    items.add(new Phone(...));
                    items.add(new Car(...));
                    // ...

                This way we can just add more to this list when we need to add an other type.
            
            Delegation
                We also might find ourselves not needing many of the inherited functions in a parent class. There unused function will still be lying around.

            Mixinx and traits
                These are a set of commonly used functions that we can mixin to an existing framwork. One might be CommonFinders. 

    Configuration
        So there will be some information that you will want to keep outside the app:
            Credentials
            Logging levels
            Port IP address, macine and cluster names
            Enviroment-specific validation
            Externally set parameters
            Site-specific formatting
            License Keys
        Anything that you know will change put it in a configuration bucket.

        Static Configuration
            You can use a table(DB) or a plain text file, for info try to keep it organized. At the start of the application the information from the file should be made global as you don't know when it will be needed, but that can lead to issues so try to wrap it in an API so that you can keep it decoupled.

        Configuration-as-a-Service
            Keeping it as an API service and help you in a few ways:
                multiple apps can share the information
                Configuration changes can be made globaly
                The data is maintained via a special UI
                Configuration becomes more dynamic
        
        Don't Write Dodo-Code
            Anything that can't addapt will die. Don't become the Dodo

Chapter 6 Concurrency (289)
    First let's start with some definitions
        Concurrency is when the execution of tow or more pieces of code ACT as if they run at the same time.
        Parallelism is when they DO run at the same time.

        Concurrency is about fibers and threads IE switching between the 2 or more a lot.
        Parallelism you need Mulitcores and more than 1 CPU.

    Everything is Concurrent
        You always try to make everything concurrent because if you try to make everything serial you will run into issues in the real world. To many things are going to happen while any site is active.

    Breaking Temporal Coupling
        This is about time, we care about to things: Concurrency (things happening at the same time), and ordering (the relative position of things in time).

        Don't get locked into the idead that everything must happen in a set time. Yoy site will never run perfectly for each user, dealing with having different modules run at differnt times will help it become more flexible.

        How do we look for concurrency? Use an activity diagram to find out which things can be concurrent and which ones need an order.
            Is a set of actions with:
                an arrow leading away from an action to an other action (ordering, can be done one first action is completed)
                or a thick line (called a synchroniztion bar, which will have actions leading into the BAR, which means all those action need to be completed to finish the task).
                Any action without a bar or line can be done at any time.

        Opportunites for Concurrency
            With the Pina Colada yes a real bartender would need 5 hands to do everything that could be done at the same time, but he will have 1 min while its blending so why not do the concurrent things then. (Remember that humans can really only do Concurrency not Parallelism).

        Opportunites for Parallelism
            Some of the best case are when you have a bunch of work that can be done indpendantly but just need all the results before moving on.

            Elixir compile uses this to compile the entire project. It processes each module in paralelle and then makes sure that if a module needs an other it waits till it is processed and then moves on.

    Shared State is Incorrect State
        Pie in a Dinner or money in the bank account if you try to sell more than you have or buy more that you can aafford because the state is being accessed at the same time someone will be sad.

        Nonatomic Updates
            So in the waiter case the memory can be accessed at the same time from many sources, display.pie_count() gets copied into their own memory then used.

            A semiphore is a way to make sure that only one person can access the data or item. You need the Leprechaun to sell a pie.

            In all cases the semaphore had to be created, and named. Also everyone that uses the Pie Case needs to follow the convention, if someone writes code that doesn't use the Semiphore then it's back to chaos.

            Make the Resource Transactional
                What if we then make the call to get pie count and deliver all the same function call. This might make it easier and not coupled with everyone being on the same page.

                With the example we go from still needing to add a semaphore
                to needing to be sure that the semaphone is unlocked
                to adding in a try and catch to be sure that everything runs as needed.

        Multiple Resource Transactions
            What happens if we add in Ice Cream? Do we just do both checks and then just hope they both go through? What happens if you grab some pie but not Ice Cream?

            WE before out all the work in the code for handling the item. But in this case it might be better to make a brand new reasource. 

        Non-Transactional Updates
            Don't think that shared memory is the only place that concurrency can be an issue. Even external files can be a place of concern. You can change a directory while working in parallel then effect things down the line etc.

            Remember that random failures are concurrency issues.
        
        Other Kinds of Exclusive Access
            So many languages have some built in things to deal with this issue like: mutual, exclusion, semaphores, etc. 

            Going into Functional Languages you might think that immutible data is the solution but at some point we need to acutally deal with the upkeep of the data we are using. 

    Actors and Processes
        This is a way of Implementing concurrency without the burden of synchroniztion. Let's define what we mean:
            Actor is a private state that has a mailbox that will kick to life when it recieves a message. You can use an actor to activate an other actor that will process based off of what it revieces. 

            Process is the overarching virtual processer that is used to facilitate concurrency.

        Actors can only be concurrent
            There is no single thing that is in control
            The only state in the system if held by the message, and messages can only be recieved by the recipent.
            Messages are one way. If you want a response you can send your PID and wait for it to eventually get back to you.
            An actor will only process one message at a time and will process to Completion.

            USE ACTORS FOR CONCURRENCY WITHOUT A SHARED STATE

        A Simple Actor
            Let's break down the Dinner into actors.
                We (as some kind of external, God-like being) tell the customer that they are hungry
                In response, they’ll ask the waiter for pie
                The waiter will ask the pie case to get some pie to the customer
                If the pie case has a slice available, it will send it to the customer, and also notify the waiter to add it  to the bill
                If there is no pie, the case tells the waiter, and the waiter apologizes to the customer.

                As the customer you can have 3 messages:
                    You are hungry (External)
                    Pie has been sent (Pie Case)
                    No Pie (Waiter)
                Customer can send:
                    I want Pie (waiter)
                
                As the Waiter you can recieve these:
                    Order (Customer)
                    add to order (Pie Case after a good return)
                    No Pie (Pie case)
                Waiter can send:
                    I want Pie (Pie case)
                    No Pie (Customer)
                    Error about item (Customer)
                    Put on table (Customer)

                Pie Case:
                    Get slice (waiter)
                Pie Case can send:
                    Add to order (Waiter)
                    No Pie (Waiter)

            We then start each actor and see what the customer wants. 
        
        No Explicit Concurrency
            What is nice here is that once you have all the Actors set up you dant have to worry about the underlying functionality. The language sets everything up for us.
        
        Erland Sets the Stage
            Everything here has been implemented within the Erland (Elixir) system. You have GenServer and states that can be sent. They are isolated and with the Supervisors that can be made everything has some built-in fault tolerance.

        What is great about this system is that you can only work on one message at a time and if you do it this way you can only access that information one at a time so concurrency takes care of itself.

    Blackboards
        So for a blackboard there are some key features that you should keep in mind:
            People can add to a blackboard and never meet an other detective
            People on the project might only share the fact that they want to solve the case.
            There can be many different shifts and people can come and go.
            ANything can be placed on the board, as long as it relates, picture, sentences, etc

        Within the coding world think of detectives as Actors or Agents, and the blackboard as a way to store and retrieve information.

        A Blackboard in Action
            In our example we have many different constraints and timings of information and retrieval. We could try and workflow every different form of workflow. But things can change at any given time.

            A messaging system can be a type of blackboard, where you have rules for and particular input and you can retrieve anything with form matching.

        But It's not that Simple
            Messaging is great for decoupling but keep in mind that it's very hard to trace everything that happens in a program. SOme of the best ways to deal with this is a trace ID and good logging.

        Exersice 24
            Image Processing: I think this could be a good use of a Blackboard system, no program needs to understand anything about the rest of the Image and everything can be done Concurrently

            Group Calendaring: While it might be a good system for adding in an person to the list It might not be the best as you will need to keep everyone involved in the picking of the time.

            Netwroking Monitoring Tool: This feels like a good system for a blackboard, key points being that anyone can access the board at any time and the logging system should be the one responsible for adding any new information. 

Chapter 7 While You are Coding 324
    Coding is not just turing ideas into lines of code. Don't get lazy about coding always be thinking about how you can improve.

    Listen to Your Lizard Brain
        First off instincts are not as easily distinguished. You might find that you have an idea and an instinct about how it should be implimented, listen to them but try to figure out why.

        Fear of the Blank Page
            The fear of starting a new project can be daunting. He are 2 ideas of why that is: lizard brain trying to tell you something, doubt lurking just below the surface.

            Let those feeling exsist and then try to push past while still listening to them, it might be that you are unsure where to start, it might be that you just don't have the understanding that you will need to complete the project. 
        
        Fighting Yourself
            You must find the way to continue to push even if you think that you are falling behind with only 1 step forward after 3 steps back. You might be failing because the data structre is off from the begining, or the functions are too loose, or your naming conventions are getting in the way.

        How to Talk Lizard
            Stop what you are doing.
            Try Externalizing the Problem.
            Prototyping!!!
        
        It's Playtime
            Starting a new project can be tough you might need to start and restart you project a few times. You might need to read a funny story and come back, you might just want to prototype something similar. If you are working on existing code try these steps:
                Write I'm prototyping on a stick note and put in on your computer
                Remindf yourseld that prototypes are meant to fail
                In your empty buffer describe what you want it to do.
                start coding.

            If you have doubts look at the sticky note, if you get a nagging doubt deal with it. IF you still feel uneasy; walk away, talk, and time off. Come back

        Not Just YOUR code
            Different is not bad just different you might get some insite on a new problem with this approach. It might be helpful to when you see something different to jot it down and then come back to it. IF you are in a supportive enviroment you can just ask why outloud.

    Programming by Coincidence
        Try to not program by luck or Coincidence to to be deliberate. 

        Accidents of Implementation, Why should we mess with something that we built that works?
            It may not be really working
            the Boundry condition may be accidentally working
            Undocumented behavior may change with a new release
            Unnessary calls make your code slower.
            Additional call make your code more bug prone
        
        You might be able to fix a bad result by "adding 1" or something but in the end it is far better to understand the information coming in and fix it at the source. Next time it might be off by 2 and that simple fix won't work.

        Don't assume prove it!!!

        Accidents of context
            There might be many times that you are going to get it right in only one context. There is many things that you might no be able to control and your test enviroment might not reflect the enviroment that your code will live in.

        How to Progam Deliberately
            What are some things that you can do:
                Be aware of what you are doing and finsh the task when you can.
                Can you explain the code in detail to a more junior programmer?
                Don't code in the dark. 
                Proceed from a plan
                Rely only on reliable things
                Document your assumptions
                Don't just test code test your assumptions
                Prioritize your effort
                Don't be a slave to history

            Exercise 25 492
                There might be many reasons that it would not work on production, but it could be a concurrency issue, It might be an issue with trying to access the same info at the same time. If it's in an array you might have duplicate fields and entries and the first to be found wins.

            Exercise 26
                You forgot about the country code, and extensions.

            Exercise 27
                In this case you might have some issues with bad versions of the stored data. Yes 16 cups are in a Gallon, but that doesn't mean that the precision of the original recipe are ready to be scaled to 5000 units.
    
    Algorithm Speed
        We might need to estimate the power reasources and time any project will take. BigO notations comes in here. Things can have many different ways of take time and processing. Linear is a good point to strive for but there are many sublinear functions.

        A 10 item processing can take a minute but if the ram and computing power of the function is intese enough 1000 will never happen.
        
    Big-O Notation
        Always worry about the upper bounds when dealing with Big-O notation. 

        O(c) is constant
        O(x) is linear
        O(x^2) is quadratic
    
        Common sense Estimation
            Simple Loops: O(X)
            Nested Loops: O(X^2)
            Binary Chop: O(log x)
            DIvied and conquer: O(X log X)
            Combinatoric: O(x^k)
        
    Algorithm Speed in Practice
        Try to find the best practice or Algorithm to suit your needs if it takes O(X^2) then try and find a divind and conquer that can get you to O(x Log x)

        If you are unsure think about running some testes with dffferent sizes of data and see what happens. Once you find the times and ram you might think about different sorts for different sizes of data. Also you never know what will happen once you get real world examples. Even getting a sorted list can mess with the data given.

        Last think about how much time it will take to improve a sorting algorithm as even if it could be better there might be limiting factors that make good enough good enough.

            Exercise 28 (493)
                Many things can effect the runtimes of your code. Is there anything else running etc
            
            Exercise 29
                Assume for a worst case we have the following:
                    set of 1000 items it can be broken into,
                    2 sets of 500
                    4 sets of 250
                    8 sets of 125
                    16 sets of 62.5
                    32 sets of 31.25 ...

                    Keep in mind that we will only need to traveser half of these as we will be able to know that its in the high or lower groups. So by the time that we are at 32 and 31 we will only have been through 16 lists. 

            Exercise 30
                I cant see the question...

    Refactoring
        Construction as a verb for coding implies a few things that are not 1-to-1:
            Architect draws up blueprints
            Contractors dig foundation, plumbers do the pipes etc
            Tenants move in and live happily every after and only call the super if there is a problem.

        We like to think of coding as garndening. You plant things and see how they grow. You need to cull weeds and fertilize plants that need more help. Some things are meant for the compost you just don't know it yet.

        Don't be afraid of having to rewrite or rework any part of the code you right at a later time. Here is the critical things to take away from this:
            Activity is disciplined, not a free-for-all
            External behavior does not change; this is not the time to add features

        When Should you Refactor?
            Duplication
            Nonoorthogonal Design
            Outdated Knowledge
            Usage (this aren't running like they did in testing)
            Performance
            The Tests Pass (Really!!)

            You can feel the pain while working with source code that does what it's supposed to. THat doesnt mean that you can't get something out of working with it.
            
        How to Refactor
            Don't try to refactor and add features
            Make sure you have good test first. 
            Take short and delibrate steps.

    Test to Code
        Testing is not about findin bugs!! You should write test that help you code.

        Thinking about Tests
            You finshed writing a new function. Now you think about having to write an new set of tests for it. Well now you know that you need to pass the function a set of DB, or now you know that you might need a helper function to get you to the state that you need in order run the function.

            Now we need to think about what the data might look like. We might need to look at other DB in order to find the users that we want. Now we have an other param that we can send with the function.

        Test Driving Coding
            A Test is the First User of Your Code.

            Boundry condition are some of the hardest things to code as it will start off with a bunch of conditions that need to be satisfied, but if you start with testing in mind you will be far more likely to have better logic when building the new code.

        Test Driven Development (TDD)
            Decide on a small peice if functionality you want to add
            Write a rest that will pass once the functionality is Written
            Run all Tests. Verify that the only failure is the new ones
            Write the smallest amount of code that will make the test not fail.
            Refactor see if you can inprove the code.

            With all this said there are things that make people a slave to this meta
                They spend too much time ensuring that they always have 100% test coverage
                Too many redundant tests. Don't just add tests to test every phase of the code writing. 

                Build End-to-End not the other 2 ways.
            
        TDD: You need to Know Where You're Going
            Don't get side tracked by trying to fix small issues as you build your data-structure or the underlying functionality. 
        
        Back to the Code.
            Component-based development is about the idea that any new component should be able to be produced and then added into the code you are working on. Even in the field we have abilities to test as we go. 
        
        Unit Testing
            Any new MOdule you should be thinking about testing. Try to find the cases that issues come up.

        Testing Against Contract
            What is the contract that we signed when we decided to take on this task? What is the intial state and where is it going to end up? Test should test the contract. This not only tests to be sure that we acomplished what we set out to do but also tests the contract to see if there was information missing.

            Many times when we set the conditions for a function or contract we are setting up some of the easiest thing to test. If the function only should accept postive numbers send a negative and see what happens. Then you can start to test random numbers in the series.

            Keep in mind that many times you will need to test many combined tests at the same time in order to fully understand the full test. Be sure you did Unit Testing on each before you combine the results. Because if a test fails while all the Individual tests are fine you know its the combination not anything you did before.

        Ad Hoc Testing
            So there are many times that we add a IO.inspect to the code when we are debugging, well those might be some of the best things to add to a test.

        Build A Test Window
            Logging might be the only way to understand what is happening within a code once its in production. You want to be able to have well documented logs so you can parse them at a later date. There might even be a need to set a hot-key or magic URL so that you can see the information as needed. There is even an other which is a feature switch that adds in needed functionality while you need it.
        
        A Culture of Testing
            You have only a few choices:
                Test first
                Test during
                Test never

    Property-Based Testing
        There might be times that you write the function and the test and you end up missing something important. It might be based on some things that are not noticed.

        Contracts, Invariants, and Properties
            Something will change with data after a function. Certain things will not change ie the length of a list. We can think of Contracts and Invariants as Properties.

            Python has some built in testing and it will test with a different set of lists hundreds at times.

        Test Data Generation
            So the Hypothesis is a built in library for Python that will generate vales for us. In the example we import 
            import Hypothesis as some

            So given something like @given(some.integers()) it will generate about 200 integers that we can use to test. You can then set some restrictions to the intergers generated @@...(some.intergers(min_value=5n max_value=10))

            You can even nest the requirments. some.list(some.integer) etc

        Finding Bad Assumptions
            There might be times where everything feels right but testing the invariaants leads us to some more edge cases than we orgiinally thought. In the case of the example testing that starting ending value + take value = starting value we found that we took more than we should have as the function and the test never tried to take more than we had.

        Property-Based Test Ofteb Surprise You
            When these types of tests fail it can be harder to find out what happened as it will be using test that will not show up during coding and normal testing. Try to always look at the values and functions given to see where the issues arrises.

            Exercise 31 (496)
                Item names will always be the same after and before ie length of the list of items is the same.
                We can check to see if we get back :ok when we need it to with the retrieve_stock

            Exercise 32
                That the area (length * width not hieght) is less than or equal to the area of the truck
                That the difference between a spot and any other crate is greater than or equal to the width of a crate.
                You can also look at packing density that is the aread of the crates over the area of the truck must be less than 1

    Stay Safe Out There
        You might need to be paranoid everyday when thinking about coding.

        The Other 90%
            You may find that you will go through: "it works" "why doesn't it work" "finally it all works I'm done" but you are really only 90% done. You still need to do the other 90% of the code.

           You should always try and pass bad params to your code to see what happens as well. Do you need to test for things that shouldnt be able to happen?

           Then add in bad actors and then you have to test for a lot of different things as well.
        
        Secrutity Basic Principles
            Here are some basic Principles that you should know:
                Minimize Attack Surface area
                    This is the sum of all access points in your system, This follows directly with orthogonality the less you write the less points people will have to mess with your code.

                    Input data is an attack vector
                        Ruby has a $SAFE = 1 which will taint external data. 

                    Unauthenticaled services are an attack vector
                        You don't know about anyone that is accessing your data through inauthenticated sources

                    Authenticated Services are an attack vector
                        Reduce the number of authorized users. If you have an old service that has any root access it is an attack point. Even old devices that are never going to be used again can be an issue.

                    Output data is an attack vector
                        Even just simple information like password has been used by an other user can be an issue. Don't give away information. 

                    Debugging info is an attack vector
                        Don't give away the debugging info make sure that any logged info can't be seen by anyone but those that need to see it

            Principle oif Least Privilege
                Try your best to use the least Privilege with the shortest duration. You can get away with root on certain times but always defer to less Privilege then add more as needed.

            Secure Defaults
                This is things like the password entry always being replaced with *, some might want to see it but many will not need that feature. An other might be that no one see an email that you signed up with as that is information that an other user might be able to do harm with.

            Encrypt Sensitive Data
                They said that many things should be kept within version control well sensitve data should NOT be kept there. API keys, SSH keys, Encryption passwords all should be kept via config files or enviromental varibales that are not with version control.

            Maintain Security Updates
                Stay on top of security updates. The largest security hacks were caused by systems that were behind on security updates. 

            Common Sense vs Crypto
                This is about cryptographic passwords etc. You're homemade crypto algorithm will be hacked in seconds let the proffessionals take care of it. Even if you know all about the latest designs you still have to keep the paswords and data for all of your users and YOU are taking on that risk. 

    Naming Things
        Naming is one of the most important ways to document a code. If you can look at a name and know what the code will do 90% of the code is writen. Try to answer the question, "why did I create this? what does this do?" Writen words are the first thing that we see and the color and font etc come after. Here are some examples:
            let user = authenicate(Credentials)

                Why not customer or buyer?

            public void decuctPercent(double amount)
                why not: public void applyDiscount(Percentage discount) 
                This did a few things changed the code to deal with what we want and added in a new class so that we can be sure that we are sending the correct information.

            Fib.fib(x) but why not call it nth() or of()

        Honor the Culture
            Try to run the syntax for the language that you are writing in.

        Consistency
            You and your team are okay to come up with vocabulary for the things that matter to the team, Order can mean something different different codeing challenges. Think about swapping memebers of small teams as well as a informal glossary. Jargon can become shorthand very quickly.

        Renaming is Even Harder
            No that no matter what you will have to refactor at sometime. You might have heard that getData acutally is write data here etc. Try to deal with these things asap as you will have many issues down the line if you dont deal with them soon.

            CHALLENGES
                When you find a function or method with an overly generic name,
                try and rename it to express all the things it really does. Now it’s an
                easier target for refactoring.

                In our examples, we suggested using more specific names such as
                buyer instead of the more traditional and generic user. What other
                names do you habitually use that could be better?

                Are the names in your system congruent with user terms from the
                domain? If not, why? Does this cause a Stroop-effect style cognitive
                dissonance for the team?

                Are names in your system hard to change? What can you do to fix
                that particular broken window? 

Chapter 8 Before the Project (403)
    So much of your project can be done in the figured out at the onset of the project try to find the right tools and scope for the issues at hand.

    The Requirments Pit
        Gathering the required tools and wisdom is not as simple as finding the needed info as a simply going and gathering the info in the world

        The Requirements Myth
            In the begining processing time was more valuable than the people working of building the code. Today isn't like that. Today it is not like that programmers help people understand whay they want. 

        Programming As Therapy
            Not always will a client talk about all their acutuall needs right off the bat. Like if you have a new project that you are working on and you hear that all orders get free shipping for orders over 50 dollars.
                Does the 50 include tax
                Does the 50 include current shipping constants
                Does it count if you order 25 e-books and 25 paper books
                International Orders?

            Try to get your questions answered and leave room for the cilent to also have more say.

        Requirements are a Process
            This should be a feedback loop. "Is this what you meant?" Is a great way to start a feedback loop. Once your code is up and running you might have even more "clients" QA, operations, etc
        
        Walk in Your Clients Shoes
            You could gain so much from working in the enviorment that you are planning to help automate. Work with a user to think like a user.

        Requirements vs Policy
            Policy is metadata. One requirement, "Only Supervisors and Personel can access this data." and "Only authorized users may access the data." are different things. One can be done with access control system that can utilize meta data. 

        Requirments Vs Reality
            You might be able to created the best way to change all the sounds on a sound board but if its not intuitive you might get little to no users. 

        Documenting Requirements
            IF you get a set if requirements that might be helpful for a documentation as it is a goal post for the current round of a project and it can help you later during refactoring. Cilents will think in high-level thoughts, we as the programmers need to think in the details. Many cilents wont read through a curated list of "requirements" as they might not even understand all that we are trying to do.

            These large volumes of requirements are for PLANNING. Try to write everything within an index card, that why if it ever gets to large for the card it might need to be broken up to better convey what we really need for the application.

        Overspecification
            Requirements are not architecture. Requirements are not design, nor are they the user interface. Requirements are need.


        Just One More Wafer-Thin Mint
            Feature bloat is a thing and the only way to really combat it is with feedback.

        Maintain a Glossary
            Terms will be created and used to take something that is large and make it more usable but without everyone on the team knowing the terms and thier meaning they are useless. 

            Exercise 33 (497)
                Under normal circumstances the response time should be less than 500ms
                Modal windows will have a darker background
                With a single backend server we will have many front facing applications
                Required
                Required

    Solving Impossible Puzzle
        Degrees of Freedom
            Sometimes it's think outside the box, sometimes it's let's find the box so that we know where the constraints are. So much of this is not letting ideas that seem crazy go. Trojan horse is an example of this. 
        
        Get Out of Your Own Way
            You should always be okay with taking a step away and comming back to a problem. Time away is the answer many times. When we are distracted we allow our brain to process and try things a different way. Here are some questions to ask if you need to see something differently:
                Why are you solving the problem?
                What's the beinfit of solving it?
                Are the problemns your're having related to edge cases? Can you eleminate them?
                Is there a simpler, realted problem that you can solve?
        
        Fortune Favors the Prepared Mind.
            Yes time away can gain you some insight but without prior knowlegde or a deeper understandin you might not have the needed prior information. 

    Working Together
        Without some guidance you might find it harder to accomplish a given task. There is a way of coding called pair programming where one person writes the code and the others try to solve issues of dictate what should be on the screen.

        Pair Programming
            The one at the keyboard is in-charge of low-level: syntax, and coding style. While the one not at the keyboard is allowed to think high-level. You can switch at any given time you need. This might help you stay more focused and stop small bits of lazyness as you are being actively watched. 

        Mob Programming
            This is the above but with the amount of people and the types of people involved a lot less stringent. You might invite a user or a salesman.

        What Should I do?
            Here are some tips for getting started with Pair/Mob Programming:
                Build the code not your ego.
                Start small
                Criticize the code, not the person.
                Listen to others viewpoint
                Conduct frequent retrospectives

            Swap out the typist every 5-10 minutes, so some reading before hand to be sure that you have some ideas and are up to date on the latest issues.

    The Essence of Agility
        Agile is nopt a Noun; Agile is how you do things. Try to value these things above others:
            Individual and interactions
            Working Software
            Customer collaborations
            Responding to change

        There can never be and Agile process
            Agile is the abilty to respond to change and anything that says, "Do this and you will be Agile" misses the point. 

        So What Do We Do?
            1. Work out where you are.
            2. Make the smalled meaningful step towards your goal.
            3. Evaluate where you end up.

            Repeat as needed. user > owner > ownerEmail what are we really trying to do?

            And This Drives Design

Chapter 9 Pragmaitc Projects (435)
    Pragmatic Teams
        A Pragmaitic team is small, under 10-12 members, with a team that rarely changes. 

        No Broken windows
            Fix issues fast as everyone will lose faith if you are constantly worried about the bug that just won't go away.
        
        Boiled Frogs
            Don't assume that someone is handeling an issue just because it was talked about, dont let things get out of hand while in a group. 
        
        Schedule Your Knowledge Portfolio
            Make sure that you are working on your teams knowledge, don't just say when we have a min. Keep learning and you will all do better. You don't just work on new code:
                Old System Maintenance
                Process Reflection and Refinement
                New Tech Experiments
                Learning and Skill Improvements

        Communicate Team Presence
            Make sure that you are always communicating withing the team but the communication with others outside the team is a very imporant part of the task. To this your team should have a brand; memos should look the same no matter who is writing them, they should be consise and to the point. You should even try to be sure that your team has a name that rings with people.

        Don't Repeat Yourselves
            Don't repeat sure but don't make it harder than it needs to be to get answers to quetsions. Be sure that you have methods for communicating.

        Team Tracer Bullets
            Don't get caught up with team being too segmented you want to have some people that might be better with certain aspects of the code, but don't create a gate when you should be able to create the app.

        Automation
            Try to use tools that you know will help for every aspect of the code cycle.

        Know When to Stop Adding Paint
            Good enough or perfect?

    Coconuts Don't Cut It
        Try to remember that just because you use x, y or z that you dont automatically get to say that you are those things. Coconuts are NOT enough. 

        Context Matters
            Try to remember that context matters you can't just adopt the same methodologies as top companies and expect them to just work in your space. Sometimes it was lightning in a bottle and sometimes it was just a great advertising campagn etc.

        One Size Fits No One Well
            Try to understant your team as well as the tools you have on hand. Try to adapt them to the culture of your team.

        The Real Goal
            Your goal should always be the customer, try to limit new feature release times to weeks or days not months. If you have the right team you should be able to deliver something like that.

            Structure can get you there. But don't become calicified.

    Pragmatic Starter Kit
        Some of the best things to look for here are:
            Version Control
            Regression Testing
            Full Automation
        
        Drive With Version Control
            Keep everything up to date and push to a remote cloud.

        Ruthless and Continous Testing
            Test with the goal of breaking the code. Testing can save a lot of money early. Test for the following:
                Unit Testing
                    Work by themselves to test larger code
                Integration Testing
                    Do they play well together?
                Validation Testing
                    Does it meet the standards of the customer?
                Performance Testing
                    How well does it work understrain?
                Testing the Tests
                    Does it catch all the bugs?

            Keep in mind that you can go through every line of code but not hit every state that the function or code will be in throughout its lifecycle.
        
        Tightening the Net
            Always be looking at the code or bug that slips through. Once you find one tighten the net.
        
        Full Automation
            Dont use a procedure when you can automate it, people are really good at finding the lack of specific rules within a written procedure.

    Delight Your Users
        Some people that you are building an app for might not even know what they want off the bat. You will need many rounds of itteration that can lead to people knowing more about the needs. You might even need a project to see what the next project will be, get more info about what an average customer needs.

        What are some things that you can do once you have a goal in mind:
            Be sure everyone is on the same page
            Find that path that leads to those expectations
            View requirements in terms of the expectations
            Keep those expectations in mind while you build

        Always keep in mind that many different forms of insight can be gained from anywhere in the company.

    Pride and Prejudice
        SIGN YOUR WORK!!!!

        Be ready to be proud of your work but also be willing to accept the faults. When you don't own-up to the work you do you might breed sloppiness. 