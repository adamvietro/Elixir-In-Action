Chapter 1 First Steps (3)
    1.1 About Erlang
        
        1.1.1 High Availability

        1.1.2 Erland concurrency
            Fault Tolerance
            Scalability
            Distribution
            Reposonsiveness

        1.1.3 Server-side Systems

        1.1.4 The Development Plaform
            Open Telecom Platform:
                concurrency and Distribution patterns
                Error Detection and recovery
                Packaging code into libraries
                Systems deployment
                Live Code Updates
        
        1.1.5 Relationship to Microservices
            A Service for this section is a part of the system running in a separate OS
            With this we can distribute the service to many different machine and then avoid the entire machine going down when 1 fails.
            One of the issues arisses when you want to completely separate the service, you might still have issues with keeping it completely separate.
        
    1.2 About Elixir

        1.2.1 Code Simplifaction
            One of the benifits from Erlang to Elixir if the reduction of boiler plate code that doesnt need to be there.
                defmodule SumServer do
                    use GenServer
                    def start do
                        GenServer.start(__MODULE__, nil)
                    end
                    def sum(server, a, b) do
                        GenServer.call(server, {:sum, a, b})
                    end
                    def handle_call({:sum, a, b}, _from, state) do
                        {:reply, a + b, state}
                    end
                end

        1.2.2 Compsing Functions
            Pipe Opperator is the glue that takes one form of data and can turn it into an other type or style.

        1.2.3 The Big Picture

    1.3 Disadvantages
    
        1.3.1 Speed
            It will be "slower" but Elixir makes up for it. The scheduler will take care of any issues and will just make the overall system slower if there is any issue with hardware, IT WONT JUST STOP.

        1.3.2 Ecosystem

Chapter 2 Building Blocks (19)

    2.1 The Interactive Shell
        iex # starts the Interactive shell
        Also keep in mind that everything returns a value if, when, for, while, enum etc
        Line breaks are the end of expression as long as they are valid that is.
        ctrl-c twice breaks the shell

    2.2 Working with variables
        Elixir uses dynamic bindings
        Only use losercase letters with underscores for more than 1 word varibales
        Remember that you are not mutating a variable you are creating a new variable and rebinding the location.

    2.3 Organizing your Code
        Use many small functions

        2.3.1 Modules
             A module is a colection of functions 

             To define a module you will need to to use the defmodule Name do
             To use the module you can type everything into the shell or use:
                iex module.file.ex # This will load the script into the shell as well.

                You can create more than 1 in a file and you can nest them as well

        2.3.2 Functions
            ? returns true/false
            ! indicates it might raise a error

            defmodule and def are MACROS

            You can omit the parenthsis when calling a function buts its not recommended

            |> Pipe Opperator will place the output of the previous function into the FIRST param of the next

        2.3.3 Function Arity
            This is the number of arguments a function will take. You can use the \\ to define default values for a param
        
        2.3.4 Function Visiblity
            Functions are by default exported unless you use the defp macro
        
        2.3.5 Imports and Aliases
            import # This will allow you to import other modules into your code.
            alias mod, as: MyIO # This will import a new module but give it a nickname

            If you dont use the syntax , as: ... 
            whatever you have after a . will be used.
        
        2.3.6 Module Attributes
            @pi some_info
            @raduis 2

            These can be used as compile-time constants and can be refrenced with 
            @pi

            @moduledoc and @doc can be used to fetch docs for the functions if you create and use them
                Code.fetch_docs(function_name)

                You can even use h function_name within the shell

            Type Specifications
                or typespecs are used to determine what the input and output of a function is.
                @spec function_name(number) :: number
        
        2.3.7 Comments
            # Comments start with the # in Elixir

    2.4 Understanding the Type System
        2.4.1 Numbers
            / # will always return a float trunc will get rid of the .0000
            div and rem will return ints
            _ can act as delimiters for large numbers 1_000_000 == 1000000

        2.4.2 Atoms
            These are literally named constants
            You can use spaces as such :"an atom with spaces"
            What is nice about atoms is that they are just kept within a atom table so you can keep the reasources low

            Aliases
                Using an uppercase letter to start will create an atom as well
                AnAtom == :"Elixir.AnAtom"

                TO go a bit further this is the same thing as the alias when you import
                    alias IO, as: MyIO
                    MyIO == Elixir.IO
                
            Atoms and Booleans
                :true == true and :false == false
            
            Nil and Truthy Values
                :nil ~- null
                nil == false and everything else it true

                || returns any value that isn't falsy
                If you sting a bunch of || together you will just get the last value if everything is false

                && returns the second expression if the first is truthy otherwise it returns the first expression

                SO you can string || to get any value that any value that exists

                Or you an string && to check if the first value is true and retrive the second
        
        2.4.3 Tuples
            To access a tuples element you can use elem(tuple, 1) # where the tuple is a tuple and the 1 is the index of the tuple you want.

            put_elem(tuple, index, value)

            Remember that you will never modify anything in Elixir you must always redifine the variable or pass the new one on

        2.4.4 Lists
            Keep in mind that it is easy to retieve the first element of a list and harder for the next and so on. It is a value and a refrence to the next element in the list.

            One of the basic ways to get an element is to use the Enum.at(list, index)

            Also there is the 'in' that will check to see if the list contains what you are passing to it
                5 in [2, 3, 4, 5]
                true

            List.replace_at(list, index, value)

            List.insert_at(list, index, value) # you can always use the -1 to append to the end of a list

            Recursive List Definition
                There is a great way to think about lists and that is with the head/tail representation

                list = [head | tail] # with this head is a single element and tail is the rest 
                list = [head | second | tail] # same with this head= single secong = single tail = rest

                Think of lists as pais, and element and a list, if you want to not use the above syntax you can use hd() or tl() # head or tail in this case

        2.4.5 Immutability
            Remember that elixir is immutable so you must always rebind a vaiable

            Modifying Tuples
                Modifying a tuple or anything really will create a shallow copy of the first bit of data and then do the work to it, if you rebind it the old data wont have a reference and be dealt with by the garbabe collector after the opperation.
            
            Modifying Lists
                So for lists you will create a shallow copy of the list up to the element that you want to change and the rest of the list will not be changed or copied as any lists is just element and a reference to the rest of the list.

            Benifits
                One of the best things about Immutability is that there is no side effects, IE you know what will change no matter what and if you want to change something you must implicitly do that thing.

                The one thing to keep in mind is that anything that you do to other databases will be permanent

        2.4.6 Maps
            These are key and value pairs

            Dynamically Sized Maps
                %{} is an empty map
                
                There are a few ways to make a map 
                squares = %{1 => 2, 2 => 4}
                squares = Map.new([{1, 1}, {2, 2}, {3, 3}])

                And then you can retieve the elements with
                squares[1] # with the value that is in the [] is the :atom/key of the element not the index
                Map.get(map, key) # will also work
                Map.get(map, key, :default) # this is different as you can set the default not found value that will be returned

                Map.fetch(map, key) # This will return a tuple with {:ok, value} or :error if not found
                Map.fecth!(map, key) will only work if the value exists and crash if not

            Structured Data
                What is nice about maps is that you can access any amount of data and change anything that you want within the map.

                %{old_map | key: change, key2: change} # this will change the values for key: and key2: only if they exist

                With this being said it is best to create a map with all the keys present and then modify them as needed nil can be the default value until you know what you want in the field

        2.4.7 Binaries and Bitstrings
            A binary is a chunk of bytes. You can create binaries by encloseing a sequence with << >> it will only store the byte up to 256 anyting higher will result in the rem of the number. However you can denote the amount of bits to use with :: so <<257::16>> 
            <<1,1>> # This expression places the number 257 into 16 bits of consecutive memory space. The output indicates that you use 2 bytes, both with a value of 1

            <> will concatenate bit strings or binaries

        2.4.8 Strings
            Binary Strings
                "This is a string" is the common way to represent a string
                #{} # This can embed elixir code within a string

                "You can also 
                    use mulit line strings"

                ~s(this is also a string) # This is using sigils if you want to use quotes in the sigil you must escape them first.

                ~S(doesnt handle escaped characters\\n) # "doesnt handle escaped characters\\n"

                heredocs is the last case and they use """ """

                same as with bit strings we can concatenate with <>

            Character Lists
                AKA charlist
                any list of intergers that can be represented as characters can and will be seen as a charlist
                ~c"ABC" is also a way to get to a charlist
                'ABC' will also work

                String.to_charlist() will convert a string to a charlist
            
        2.4.9 First-Class Functions
            Within elixir we can assign a FUNCTION to a variable so in that case we are creating an anonymous function or a lambda

            once it is named you can use the (.) to call it with an input # This is because we want to differentiate the difference betweened a named function and the lambda.

            So if you want to use an Enum.each() you can set a function before and then pass a list and the function without describing the function in the Enum.each() call.

            Let's add and other bit of sugar: if you want to just skip the complete setting of a function you can use the &IO.puts/1 # This is the capture Opperator.
                Where the & sets the function and then you can pass &1 &2 &3 etc where they will refrence the first second and third arguement that is passed.

            Closures
                A lambda can reference any variable outside it's scope. So with this you can keep a reference to any outside variable if the function is still held with a reference. This is called closure.

                Keep in mind once the closure is set changing the outside varibale will NOT change the closure.
        
        2.4.10 Other Built-In Types
            A reference: Kernel.make_ref/0 this will only be saved for the instance that calles it

            a process idenifier(PID): This is used for dealing with different processes

            the port idenifier: IO is the comunication tool.

        2.4.11 Higher-Level Types
            Range
                number..other_number # this will create a range from the number to an other_number
                These are also enumerable
            
            Keyword Lists
                This is usually set with days = [{:monday, 1}, {:tuesday, 2}] # but can be sortend to 
                    days= [monday: 1, tuesday: 2]

                The Keyword module is used in this case. Keep in mind this is still a list and complexity is still O(n) many diffent function will use this syntax to add additional options to a function.

            MapSet
                Use the MapSet module here and you can add in and store uniuqe values, with the value being of any type.
            
            Times and Dates
                Here are some types that we can use here:
                    Date (~D), Time(~T), DateTime(~U), NaiveDateTime(~N).

                    Once you set the values you can cakl them with the (.) notation hour minute etc

        2.4.12 IO Lists
            This is used to forward output that will be send to and IO device
            iolist = [[[~c"He"], "llo,"], " worl", "d!"] # This is just "Hello World!"

            What is nice is that you can incrementaly set all the things you want sent
                iolist = []
                iolist = [iolist, "This"]
                iolist = [iolist, " is"]
                iolist = [iolist, " an"]
                iolist = [iolist, " IO list."] # This will append all the new things that will be sent

        2.5 Opperators
            1 == 1.0 # weak Opperator       true
            1 === 1.0 # strict Opperator    false

            and, or, not

    2.6 Macros
        Lots of what helps to run elixir code is the macro. defmodule and def are parts of the macro they help to change the syntax of the code you write.

    2.7 Understanding the Runtime
        2.7.1 Modules and Functions in the Runtime
            Module Names and Atoms
                When you create a module you are in fact creating a file that will be run.

            Pure Erland Modules
                Now let's talk about this syntax
                    :code.get_path

                Everything that y=ou create will spawn a file with the name xyz.beam  and they will corrispond to an atom

            Dynamically calling Functions
                You can Dynamically call function with teh Kernel.apply/3
                This recieves 3 arguements: the module atom, the function atom, and the list of arguements. Shortend to (MFA) 

        2.7.2 Starting the Runtime
            Interactive Shell
                This wont run as fast as a pure complied code so keep that in mind as it need to interpret the code first

            Running Scripts
                elixir my_source.ex # This will run through the following every time
                    Beam is started
                    File is compiled in memory
                    Whatever code resides outside of the module is interpreted
                    Once everyting is finished the Beam is stopped.

                If you want to designate that it's a script file append s (exs) where the s stands for script

                So if we had:
                    defmodule MyModule do
                        def run do
                            IO.puts("Called MyModule.run")
                        end
                    end
                    MyModule.run

                If you want to make sure the BEAM doesnt stop on the end you can append --no-halt before the script name # elixir --no-halt script.exs

            The Mix tool
                This is used to make and use project made up of multiple source files.
                    mix new my_project
                    cd my_project
                    mix compile

                The compile goes through all the source files and places the resulting .beam files in the ebin folder

                You can execute functions with the 
                    mix run -e 

                You can also run test with the
                    mix test # This will find the test files and run them for you and let you know if there are issues

    Summary
         Elixir code is divided into modules and functions.
         Elixir is a dynamic language. The type of a variable is determined by the value it
        holds.
         Data is immutable—it can’t be modified. A function can return the modified
        version of the input that resides in another memory location. The modified ver-
        sion shares as much memory as possible with the original data.
         The most important primitive data types are numbers, atoms, and binaries.
         There is no Boolean type. Instead, the atoms true and false are used.
         There is no nullability. The atom nil can be used for this purpose.
         There is no string type. Instead, you can use either binaries (recommended) or
        lists (when needed).
         The built-in complex types are tuples, lists, and maps. Tuples are used to group
        a small, fixed-size number of fields. Lists are used to manage variable-size collec-
        tions. A map is a key–value data structure.
         Range, keyword lists, MapSet, Date, Time, NaiveDateTime, and DateTime are abstrac-
        tions built on top of the existing built-in types.
         Functions are first-class citizens.
         Module names are atoms (or aliases) that correspond to .beam files on the disk.
         There are multiple ways of starting programs: iex, elixir, and the mix tool.

Chapter 3 Control Flow (69)
    3.1 Pattern Matching
        We can start with the = (match Operator)
    
        3.1.1 The Match Operator
            We might at first think of this as an assignment but something more is going on. The left side is called the pattern and the right side is the expression.
        
        3.1.2 Matching Tuples
            {name, age} = {"Bob", 25} #  This is a form of pattern matching

            This is very useful if a function returns a tuple and you want to bind each bit of data to separate variable.

            We could even take some of the outputs and divide them further.

            There is also issues if the right and left sides don't match
                {name, age} = "can't match"
                ** (MatchError) no match of right hand side value: "can't match"

        3.1.3 Matching Constants
            1 = 1 # This is a valid elixir expression 
            quick side note when creating a tuple you can add an extra field in the begining that will denote what kind of tuple you are making
                person = {:person, "bob", 25}

            Many times with elixir functions will return {:ok, value} or {:error, reason} lets look at this next line of code.
            {:ok, contents} = File.read("my_app.config")
                attempts to opens a file
                if successful file is extracted and then the contents are sent as contents
                if it fails error is raised and it will tell you the reason

            You this syntax to write better cases and help deal with bad results
        
        3.1.4 Variables in Patterns
            Aonymous variable is the (_) this will help you still pattern match but ignore data you don't need. You can even still have a descriptive name that will not issue a warning if not used.

            You can even nest pattern matching:
                {_, {hour, _, _}} = :calendar.local_time()

            What is nice is that you can even pattern match with the names of the variables
                 {value, value, value} = {127, 127, 127} # this works
                 {value, value, value} = {127, 127, 1}  # this doesn't work

            Sometimes you will want to pattern match against an allready existing value, this is where the pin operator (^) comes in.
                expected = "bob"
                {^expected, _} = {"bob", 25}

                {^expected, _} = {"alice", 31}  # This will raise an error

            The ^ will be treated as if you hard coded the value as "bob"

        3.1.5 Matching Lists
            You can match to any element of a list
                [first, second, third] = [1, 2, 3]

                We could also use any of the above as well

            There is a common syntax for matching to elements of a list
            [head | tail] = [1, 2, 3]
            
            There is an elegant way of using matching and the pipe with min
                [min | _] = Enum.sort([3,2,1])
            Keep in mind that the hd() might be more elegant but this works as well

        3.1.6 Matching Maps
            The following is the general way that you would pattern match with a Map:
                %{name: name, age: age} = %{name: "Bob", age: 25}
            Keep in mind that when pattern matching with a Map you don't need to have every key on the left hand side
                %{age: age} = %{name: "Bob", age: 25}
            You will need to have the key present with the right hand side or you will be given an error
            
        3.1.7 Matching Bitsrtings and Binaries
            You can pattern match with binaries as well
                iex(1)> binary = <<1, 2, 3>>
                <<1, 2, 3>>
                iex(2)> <<b1, b2, b3>> = binary
                <<1, 2, 3>>

            There is a way to match the first and then the rest of a binary
                iex(6)> <<b1, rest :: binary>> = binary
                <<1, 2, 3>>
            This states that the rest will be of an abbitrary bit size

            You can even separate then into specific sizes
            <<a :: 4, b :: 4>> = << 155 >>
            << 155 >>
            This says that we want then into four-bit sizes

            This is every helpful when trying to parse packed binary contents
        
            Matching Binary Strings
                Recall that strings are just binaries
                    <<b1, b2, b3>> = "ABC" # So you can take any string and break it into its parts

                That is great for any single character, but what about strings
                command = "ping www.site.com"
                "ping " <> url = command
        
        3.1.8 Compound Matches
            You can nest as you need any pattern matching
                [_, {name, _}, _] = [{"Bob", 25}, {"Alice", 30}, {"John", 35}] # or
                a = (b = 1 + 3)

            Now let's look at a better example
                {_, {hour, _, _}} = date_time = :calendar.local_time()
                Keep in mind that the pattern matching will only occur with the values that is not being ommited.

        3.1.9 General Behavior
            Pattern = term

    3.2 Matching with Functions
        This is one of the most powerful uses of pattern matching
            defmodule Rectangle do
                def area({a, b}) do
                    a * b
                end
            end 

        This just means that the param passed to the area function will be of the form {a, b}
        If you don't pass a tuple there will be an issue, you could then try and deal with the cases where you would not send a tuple and have more robustness

        3.2.1 Multiclause Functions
            What if you wanted to define a function that could take different shapes.
                rectangle = {:rectangle, 4, 5}
                square = {:square, 5}
                circle = {:circle, 4}

            defmodule Geometry do
                def area({:rectangle, a, b}) do
                    a * b
                end
            
                def area({:square, a}) do
                    a * a
                end
                def area({:circle, r}) do
                    r * r * 3.14
                end
            end 

            You can see in this case the pattern match will only call the right function if passed the right tuple. Keep in mind that you are creating a single function with clauses. In this way you can't just access one of the clauses. Recall the & that will capture a function. 

            fun = &Geometry.area/1

            What is nice about the clauses is that you can then create all the proper function clauses and then create a dummy function that will take anything else.
                def area(unknown) do
                    {:error, {:unknown_shape, unknown}}
                end

            This must go at the end as it will always try to go through the clauses from top to bottom and this will always pass. Also keep in mind that a function cares about Name and Arity.

        3.2.2 Guards
            This is helpful for when you want to be sure that you only call a function with the correct data type or values for the param.

            defmodule TestNum do
                def test(x) when x < 0 do
                    :negative
                end
                def test(x) when x == 0 do
                    :zero
                end
                def test(x) when x > 0 do
                    :positive
                end
            end

            This will test the number and only call the right function if the number is the right value.
            One thing to keep in mind is that elixir can compare different data types with this syntax
                number < atom < reference < fun < port < pid < tuple < map < list < bitstring (binary)

            With this in mind we see that a number is always the smallest and we can then extend the Guard to deal with that by adding # when is_number(x) and x > 0 and so on.

            Keep in mind that only certain operators can be called within a Guard:
                Comparison
                Boolean
                Arithmetic
                Type-check

            So last bit is that the error in a Guard will not return an error it will just make the Guard expressoon false and move on to an other function definition.

        3.2.3 Multiclause Lambdas
            You can use different clauses within a function definition to separate out the different inputs. This will also be used with Lambdas
                test_num =
                    fn
                        x when is_number(x) and x < 0 -> :negative
                        x when x == 0 -> :zero
                        x when is_number(x) and x > 0 -> :positive
                    end

            As you can see here we have differnt types of Guards within a lambda.
        
    3.3 Conditionals
        If and Case can be used for multicase conditionals. You can also use pattern matching to get a little bit more out of your functions.

        3.3.1 Branching with Multiclause Functions
            defmodule TestList do
                def empty?([]), do: true
                def empty?([_|_]), do: false
            end

            Then you can also use Guards for different data types.
                defmodule Polymorphic do
                    def double(x) when is_number(x), do: 2 * x
                    def double(x) when is_binary(x), do: x <> x
                end

            Recursion is a great example of multicase because you can set the base case with a static param.
                defmodule Fact do
                    def fact(0), do: 1
                    def fact(n), do: n * fact(n - 1)
                end
            Here we have the base case and then everything else falls from that. You can do a summation for a list with some of the same things.

        3.3.2 Classical Branching Expressions
            if, unless, cond, case are things that might be better than Multiclause as you will have to recreate the function with guards and still pass the proper param.

            If and Unless
                if condtion do
                    ...
                else
                    ...
                end
                
                For the one liner we use
                    if cond, do: thing, else: other_thing
                Keep in mind that EVERYTHING in elixir will return a value

                unless result == :error, do: something_else

            cond
                cond do
                    expression_1 -> 
                        ...
                    expression_2 ->
                        ...
                    ...
                end
                These are used when you can't just pattern match with the value or you have different things to check against. You can also have a defualt case with the last one simply being true -> ...

            case
                case expression do
                    pattern_1 ->
                        ...
                    pattern_2 ->
                        ...
                    ...
                end
                The big difference here is that the expression has to pattern match with the expression. You can simply pass a variable that will be evaluated or you can make the expression something that will need to be evaulated. The default pattern will be _ ->

        3.3.3 The with Expression
            This is useful for when you want to chain a couple of expression and then return the error of the first expression that fails. You want to process registraion data.

                %{
                "login" => "alice",
                "email" => "some_email",
                "password" => "password",
                "other_field" => "some_value",
                "yet_another_field" => "...",
                ...
                }
            
            We want to only worry about login:, email:, password: if you always have the right map it will never have an issue but what if you can't be sure that will happen. You want to return {:ok, result} or {:error, reason}

            If you were to use pattern matching and case to make sure that all the fields are right you might need to have nested cases and it might not look very good. However you can use with:
                with pattern_1 <- expression_1,
                    pattern_2 <- expression_2,
                    ...
                do
                    ...
                end

            For this you will go through each pattern and do the expression if all pass you go onto the do, if any fail the issue is returned as an error.

                def extract_user(user) do
                    with    {:ok, login} <- extract_login(user),
                            {:ok, email} <- extract_email(user),
                            {:ok, password} <- extract_password(user) do
                        {:ok, %{login: login, email: email, password: password}}
                    end
                end
    3.4 Loops and Itterations
        The pricipile looping structure in Elixir is Recursion.
        3.4.1 Iterating with Recursion
            With many of these examples we want to go through the list or numbers 1 by 1. You start at the "end" of the list and then go to the front recursively. That way you print the front then go back through the list.

        3.4.2 Tail Function Calls
            If the last thing a function does is call a function (or itself) then it's considered a Tail Function. Tail Recursion dfoesnt consume any more resources.

            defmodule ListHelper do
                def sum(list) do
                    do_sum(0, list)
                end
                defp do_sum(current_sum, []) do
                    current_sum
                end
                defp do_sum(current_sum, [head | tail]) do
                    new_sum = head + current_sum
                    do_sum(new_sum, tail)
                end
            end

            Recognizing Tail Calls
                So for this you must have only the call to an other function as the last line
                def fun(...) do
                    1 + another_fun(...)
                end # This is NOT a tail call as there is more than just a call to a function on the last line.

            Practice
                See the files that I add to the folder.

        3.4.3 Higher-Order Functions
            This is when you have a function that takes one for more functions as input or returns one or more functions.

            Enum.each/2 takes and enumerable and a lambda therefore it's a higher order function.
            Enum.map/2 is also a Higher order function.
                Enum.map(list, &(2 * &1)) # simplfied lambda that uses &n to take the place of the nth arguement

            Let's talk about filter for a second
                With this you can something like this
                case Enum.filter(
                            ["login", "email", "password"],  # Sets the different things to look for
                            &(not Map.has_key?(user, &1)) # Shorted Lambda to check a difined user
                        ) do
                    [] -> # Returns nothing if its not missing as we check not has_key
                        ...
                    missing_fields -> # If the field is missing then we do something
                        ...
                end # You could then pass all of this to an Enum.map/2 to keep all the fields

            Reduce
                Enum.reduce/3 is probably the most useful of all the Enums as it can do some much.
                    Enum.reduce(
                        enumerable,
                        initial_acc,
                        fn element, acc ->
                        ...
                        end
                    ) # It will follow this syntax

                You can use operators to turn the function into something more consise with &+/2, &*/2
                    Enum.reduce(list, 0, &+/2) # Will add the values of the list.

                Remembet that you can always have different conditions (multiclass lambda) for pattern matching with any lambda you write:
                    Enum.reduce(list_with_not_a_number, 0, fn 
                            element, sum when is_number(element) ->
                            sum + element
                            
                            _, sum -> 
                            sum
                            end
                            ) # With this we will always try to make to is_number/1 but if not then we just do nothing with the acc

                With all this being said it is more Elixir to have cleaner code and you might just make a helper function that will be called in the place of the single lambda.

                    defmodule NumHelper do
                        def sum_nums(enumerable) do
                            Enum.reduce(enumerable, 0, &add_num/2)
                        end
                        defp add_num(num, sum) when is_number(num), do: sum + num
                        defp add_num(_, sum), do: sum
                    end # In this way you have a clean function that will still have pattern matching (multiclass)

        3.4.4 Comprehensions
            Denotes another expression that can help you iterate and transform enumerables.
                for x <- list do
                    x*x
                end

            This is great for permutations and things like that. These will iterate through anything that is enumerable. You can add in the into: to make the for a lambda and have it work for anything you put into it:
                multiplication_table =
                    for x <- 1..9,
                        y <- 1..9,
                        into: %{} do # This specifies the collectable
                    {{x, y}, x*y}
                end
                This will populate the entire table for the multiplication_table for the numbers 1..9:
                    Map.get(multiplication_table, {7, 6}) # This will pull the key for the {7,6}

                IF you want to do some more filtering for the list you can then use an other param in the defintion.
                    for ...
                    ,...
                    , x >= y # This line will ensure that you only return the values for x and y that work with the check.

                This can also iterate through a binary but the syntax is different

        3.4.5 Streams
            This is a special kind of enumerable tha can be useful for lazy composable operations. Let's say that you want to index and print the list of employees

            First you would Enum.with_index/1 then Enum.each/2 to get the list. The problems here is that you are going through the list twice once for each Enum.

            So there is a few things about stream that we should go over first is that it only creates the stream and nothing else. You will tell it what to do with the stream but you will need to then output it to a list or something you need.
                stream = Stream.map([1, 2, 3], fn x -> 2 * x end) # This created the stream
                Enum.to_list(stream) # This takes the stream and does something to it.

            Now remeber that this is a lazy way of doing things it will only do what you ask it for an nothing else. You can use this to your advatage with Enum.take/2
                Enum.take(stream, 1)

            Now back to our example we can use the Stream.with_index/1 and knowing how the index is written you can itterate the entire list with some small changes.
                employees
                |> Stream.with_index()
                |> Enum.each(fn {employee, index} -> 
                    IO.puts("#{index + 1}. #{employee}")
                end) # Very elegant solution to the problem

            You can do a lot with this and continue to pass more and more into the Stream as needed.
                [9, -1, "foo", 25, 49]
                |> Stream.filter(&(is_number(&1) and &1 > 0))
                |> Stream.map(&{&1, :math.sqrt(&1)}) 
                # This was the hardest to get my head around as you are making a consise lambda and then taking 
                # the first arguement to create a tuple with the number and sqrt.
                |> Stream.with_index()
                |> Enum.each(fn {{input, result}, index} ->
                    IO.puts("#{index + 1}. sqrt(#{input}) = #{result}")
                end)

            Keeping in mind the syntax and format of the output of each function. This is also done in a single pass for each element of the list not running through it every time a new Enum is done.

            There is also the file stream to go through each line of a file one at a time WITHOUT putting the entire file into memory.
                def large_lines!(path) do
                    File.stream!(path)
                    |> Stream.map(&String.trim_trailing(&1, "\n"))
                    |> Enum.filter(&(String.length(&1) > 80))
                end
            
            Infinite Streams
                What about infinite streams Stream.iterate/2 can come in here. This one will just conitinue to itterate over the function that you pass it

                Stream.repeatedly/1 will work just as above but is meant to go through a file or stream.

    Practice Exercises
        Again see the pages that I add to the folder

Chapter 4 Data Abstraction (112)
    Instead of classes you use modules, also remember that Elixir is immutable so you will always have to rebind the output into the same or an other variable. They might be modifiers and they might be query function but they useually will take and return the same value types.

    4.1 Abstracting with Modules
        So without going into the schemaless you can abstract a new data type with the MapSet.new() and MapSet.put/2

        4.1.1 Basic Abstraction
            `D[] is the syntax for a date type
            While we are trying to create a todo-list we want to have a special module for just the todo-list.

            You can create a new list with the def new, do: %{} 

            Then once you have the date and title you can add in the update/add functionality

            Once that is done you can add the get_entries based off a date. Keep in mind that this will not store the data within anyting you must pass the map to the function after binding it.

        4.1.2 Composting Abstractions
            You can always take some of the code and move it to an other module. In this way (with the proper nameing)  things will looks more clear. LIke in the example you will create a function/module that will take the add/remove lookup and make it their own functions.

        4.1.3 Structuring Data with Maps
            Now keep in mind with the above you are manually hardcoding the date to add to the todo, if you were to want to change the entry to an other date type you will break the functionality. What if there was a way to pass everything all at once and then get the information from that item.

            This is were Maps can help again. Put everything into a map and use the (.) notation to pull the iunformation that you need.

        4.1.4 Abstracting with Structs
            With this example we will be trying to deal with fractions. When dealing with a struct you want to use this syntax:
                defmodule Name do
                    defstruct a: nil, b: nil
                    ...
                end

            And to invoke the new struct:
                %Name{$info goes here}

            One thing to keep in mind is that you can pattern match a struct to a struct but a struct is NOT a map.
            You can add or update a struct like a map:
                struct = %Name{other_struct | b: 4} # assuming that b is a valid key.

            Check out the module that I created for this but you can always use the (.) notation to decompose the fields

            Structs vs Maps
                One thing to keep in mind is that you can't Enum a struct they are special.
                But you can use the Map module in the same way with Structs. Wierd thing here is that a Map can match a struct, but a struct can't match a map. This is because to match to a struct you must have all the fields present and the struct has the __struct__ and the name in the field.

            Records
                defrecord and defrecordp 

        4.1.5 Data Transparency
            Data is almost never hidden within Elixir. You will have everyting out in the open unless you take away some of the functionality. Most of the outputs will have some flare attached to it from the way the functions return values. The IO module has an inspect that will show more raw data.

            Also keep in mind that the return value of an inspect will alays be the thing that is sent to the inspect. So with label: and pipeing you can debug more easily.

    4.2 Working with Hierarchial Data
        We want to add CRUD support.

        4.2.1 Generating IDs
            To do this we need to do 2 things:
                Represent the to-do list as a struct as we have more information in the struct ID and the entry
                Use the entries ID as the key

            See the module that I added.

            If you want to get all the values from a Map you can use the Map.values/1

        4.2.2 Updating Entires
            first you look up the id with Map.fetch/2 then you update with the lambda that we pass into the function.

        4.2.3 Immutable Hierarchial Updates
            1 You take the target entry into a separate variable.
            2 You call the updater that returns the modified version of the entry to you.
            3 You call Map.put to put the modified entry into the entries collection.
            4 You return the new version of the to-do list, which contains the new entries
            collection.

            So as this is Hierarchial data you can't just update any part of the data you must walk down the tree to get to the place that you want to change create a copy and then change what needs to be changed.

            Provided Helpers
                Kernel.put_in/2 is a macro that allows you to get to the right place and change a value.
                You will need to use [] and (.) notation to get to the proper place but once there you will be able to change values. Again this is immutable so you must bind the new struct or map.

            Deleting an Entry
                You will need to get to the location then Map.delete\2
        
        4.2.4 Iterative Updates
            So now we want to add in a bunch of new todos in one function call. It is not that tough as long as we can set the map for the entires in one swoop. Let's use the Enum.reduce/3

            We have the functionality for the add_entry/2 already we just need to keep updating the todo_list in the reduce. Remember that you can have ANYTHING for the acc.

        4.2.5 Exercise: Importing from a file.
            See the supporting page for the things that I came upwith but it works just not with the stream. 
            Going to create a new one that will work with the stream.

    4.3 Polymorphism with Protocols
        So when building programs you will need to work with functions that will do different things based on what is passed to them this is the idea with Polymorphism. Each time you use an Enum you are asking it to look at what is being passed and then do something different.

        4.3.1 Protocol Basics
            This is a module in which you declare functions without implementing them. Let's look at the String.Chars
                defprotocol String.Chars do
                    def to_string(term)
                end
            
            You can then pass things that can be represented as a string to this function. There are helper functions that Elixir uses as alias, like, to_string etc. What is nice about this is that it will determine the why it is run at RUNTIME.

        4.3.2 Implementing Protocol
            once you have the basic idea about how to create a protocol you can then start to work with defining what happens when you call it with different data types.

            You can use the following syntax for this as well.
                defimpl String.Chars, for: Integer do
                    def to_string(term) do
                        Integer.to_string(term)
                    end
                end
            As you can see we are setting what the String.Chars does for the integer data type. Keep in mind that you can pass any to the for: to have a fall back function. Keep it at the end so that it doesn't get triggered at all times. Also looking below you can implement this for ANY data type.

                defimpl String.Chars, for: TodoList do
                    def to_string(_) do
                        "#TodoList"
                    end
                end

            What is crazy here is that you can place this anywhere in your code and it will still try to implement the things that you pass to it.

        4.3.3 Built-In Protocols
            Elixir comes with some predefined protocols. While mmany functions have some good use to change, you can do things with the Inspect!!! to change how it prints for any given type. One of the most powerful will be the Enum. These are closely related to the Collectable Protocol.

            Take a look at the todo.ex and see the end. This is taking the collection protocol and making sure that when you see a TodoList and an Enum.into/1 you will go through the list and replace the simple into function with something that will add each item into your TodoList struct.

    Summary
         A module is used to create an abstraction. A module’s functions create, manip-
        ulate, and query data. Clients can inspect the entire structure but shouldn’t rely
        on its shape.
         Maps can be used to group different fields together in a single structure.
         Structs are special kinds of maps that allow you to define data abstractions
        related to a module.
         Polymorphism can be implemented with protocols. A protocol defines an inter-
        face that is used by the generic logic. You can then provide specific protocol
        implementations for a data type.

Part 2 Concurrent Elixir
    Now we get to learn about concurrency

Chapter 5 Concurrency Primitives (141)
    5.1 Concurrency In BEAM
        Fault Tolerance
        Scalability
        Distribution

        While going through this chapter be sure to understand that Process is not an OS process as they are more bulky and BEAM Process will be lighter. There is a built in event handler that takes care of the Distribution. BEAM will use as many schedulers as there are physical Cores in your machine.
        Each Process (handled by the scheduler) take microseconds to start and has a very small memory presence. 
    
    5.2 Working with Processes
        Let's assume that you want to run some long queries, that take 2 seconds a piece. IF you want to run them one after the other it should take 10 seconds.

        5.2.1 Creating Processes
            To create a process we need to use the function spawn/1, to keep track of the process that is running the spawned VM you will have a PID assigned.
            async_query = # This function will take the param
                fn query_def -> # Pass it here
                    spawn(fn ->
                    query_result = run_query.(query_def) # Then pass it here to be run with the lamda above
                    IO.puts(query_result)
                    end)
                end

                async_query.("query 1")

            Let's take a look at this as it shows a few things that you should need to know. Looking at the comments we see that we are passing the information down through the tree and it will need to be coppied deeply as processes can't share and information.
                Enum.each(1..5, &async_query.("query #{&1}")) # This will return all 5 at one time. because it will call the spawn 5 times asyncely.

        5.2.2 Message Passing
            There will be times that you want to do basic calculation within many processes and then pass all the data to a higher process to do the rest of the work. We will use messages here to take care of this.
                receive do
                    pattern_1 -> do_something
                    pattern_2 -> do_something_else
                end

                send(pid, {:an, :arbitray, :term})

            These messages will be processed in the FIFO pattern and can and will only be limited by the memory of the system. Looking at he above we can still pattern match if we want. Keep in mind that you must pattern match to the block of code and you must have a message in order for the recieve to work. There is a block that you can use to be sure that something happens:
                receive do
                    message -> IO.inspect(message)
                after
                    5000 -> IO.puts("message not received")
                end

            Recieve Behavior
                SO there are a few cases where a failed pattern match will not fail and will not raise an error and recieve is one of them. It will simply move on to the next message and put the fail message at the end of the queue.
                    1 Take the first message from the mailbox.
                    2 Try to match it against any of the provided patterns, going from top to bottom.
                    3 If a pattern matches the message, run the corresponding code.
                    4 If no pattern matches, take the next message, and start from step 2.
                    5 If there are no more messages in the queue, wait for a new one to arrive. When
                    a new message arrives, start from step 2.
                    6 If the after clause is specified and no message is matched in the given amount
                    of time, run the code from the after block.

                Remember that EVERYTHING has a return value and the recieve is no differnt it will return the last line before the end break.

            Synchronous Sending
                This uses the "Fire-and-forget" method and will not care about whether the reciever got or processed the message, in order for both parties to know what is happening you have to specify what you need. You can do it with an other send()/2 but then both parties need to know what to do as well as have a need for this.

                You will need to send the caller PID in order to get a call back.
                    send(pid, {self(), some_message}) # Self here is the PID
                    receive do
                        {:response, response} -> ...
                    end

            Collecting Query results
                Now we want to store all the messages into one main process.
                async_query =
                    fn query_def ->
                        caller = self() # Stores the Pid in the main calling process

                        spawn(fn ->
                        query_result = run_query.(query_def)
                        send(caller, {:query_result, query_result}) # Sends a response
                        end)
                    end

                Enum.each(1..5, &async_query.("query #{&1}")) # Sends the 5 messages, but nothing the main process does changes.

                get_result = # Create a lambda to recieve the messages
                    fn ->
                        receive do
                        {:query_result, result} -> result
                        end
                    end

                    results = Enum.map(1..5, fn _ -> get_result.() end) # Store the messages into a list.

    5.3 Stateful Server Process
        The idea that you might want to create a long-running processe sthat can server various requests. This is stateful sever process.

        5.3.1 Server Processes
            A server process is an informal name for a process that runs for a long time (or forever). In order to achieve this you will need to raun tail recursion (to reduce the memory and CPU needed)

            defmodule DatabaseServer do
                def start do
                    spawn(&loop/0) # Starts the process
                end

                defp loop do
                    receive do # recieves a message
                    ...
                    end

                    loop() # Continues the loop.
                end

                ...
            end

            It is standard to put the entire code for the process into it's own module and have 2 types of functions within:
                interface (public) and implementations (private) I will put the code here as well but make sure to check out the addtional Chapter 5 livebook. Things to keep in mind is that you want to wrap all the message passing within helper functions that will make sure that the cilent will not see all the way you pass messages. You will also want to wrap any query so that you can make it easier to parse the issues that you might see within the code.

            Server Processes are Sequentail
                Everything within a server is done one at a time. This can be helpful if you want to understand a bug or the process. With that being said you can do more at the same time by creating a pool of processes. 
                    pool = Enum.map(1..100, fn _ -> DatabaseServer.start() end) 
                    # This will create a list of 100 process (with PID) stored so you can accesss any of them

                    You then need to pick a process to do the work. 
                    Enum.each(
                        1..5,
                        fn query_def ->
                            server_pid = Enum.at(pool, :rand.uniform(100) - 1)
                            DatabaseServer.run_async(server_pid, query_def)
                        end
                    ) # This is not efficient as the process of choosing takes O(N) and you might send the same one more than 1

        5.3.2 Keeping a Process State
            You will need at times to keep data within the state and as such you will need to continue to pass the state with the loop here is the standard process for that:
                def start do
                    spawn(fn ->
                        initial_state = ... # sets the state that will be used.
                        loop(initial_state)
                    end)
                end
                defp loop(state) do
                    ...
                    loop(state) # keeps the state
                end

            We can then use this to change our DatabaseServer to keep and pass a state.
            def start do
                spawn(fn ->
                connection = :rand.uniform(1000)
                loop(connection)
                end)
            end

            after we set the loop and the start to include the state it is a simple matter to make sure the state is sent with it: 
                In this case we are useing the start to make a connection to a random pid (not actually but pretending that)
                Then passing the state to the loop.
                The loop will wait for a message from a "User"
                The user can then use the run_async to pass the pid and the "query"
                The run_async will then send the message to the server (with the helper function) that will describe the query
                The run_query will then do the "query" and then hold the message within the stack
                The user can then recieve the message from the stack with the get_result 

        5.3.3 Mutable State
            We want to create a calculator that will hold the current value within the state and the a user can get to the value with a get.
            
            Let's look at the inner loop first
                def loop(current_value) do
                    new_value =
                    receive do
                        {:value, caller} ->
                        send(caller, {:responce, current_value})

                        {:add, value} ->
                        current_value + value

                        {:sub, value} ->
                        current_value - value

                        {:mul, value} ->
                        current_value * value

                        {:div, value} ->
                        current_value / value

                        {:clear, _} -> current_value = 0

                        invalid_request ->
                        IO.puts("invalid request: #{inspect(invalid_request)}")
                        current_value
                    end

                    loop(new_value)
                end

            This is pretty simple as all we are doing is setting the new_value based off of what we recieved from the current state and the atom that tells us the opperation to do

            Next lets set the value function. and the functions that will do the Arithmetic.
                def value(server_pid) do
                    send(server_pid, {:value, self()})

                    recieve do
                    {:response, value} ->
                        value
                    end
                end

                def add(server_pid, value), do: send(server_pid, {:add, value})
                def sub(server_pid, value), do: send(server_pid, {:sub, value})
                def mul(server_pid, value), do: send(server_pid, {:mul, value})
                def div(server_pid, value), do: send(server_pid, {:div, value})

            Again pretty simple as we will need a function that will send the current_value and functions that will send the right message to the server.

            Now that we have this all setup we can then do something to the loop to make it more consise while adding in a help function to process the message.
                defp loop(current_value) do
                    new_value =
                    receive do
                        message -> process_message(current_value, message)
                    end

                    loop(new_value)
                end
                

                defp process_message(current_value, {:value, caller}) do
                    send(caller, {:responce, current_value})
                    current_value
                end

                defp process_message(current_value, {:add, value}), do: current_value + value
                defp process_message(current_value, {:sub, value}), do: current_value - value
                defp process_message(current_value, {:mul, value}), do: current_value * value
                defp process_message(current_value, {:div, value}), do: current_value / value
                defp process_message(current_value, {:clear, value}), do: 0

            This one will take the same logic for the response and turn it into one set of logic that will use the process_message to do the work
        
        5.3.4 Complex States
            What if we want to keep and update a TodoList for the state of the server. First we need to put both the TodoList and the new TodoServer into the same module and then implement all the function that we need.

            Keep in mind that we will need a public function that a user can use to do and action and then a private function that will pass the data and the pid so that we can add things to the stack and process them.
                def add_entry(todo_server, new_entry) do
                    send(todo_server, {:add_entry, new_entry})
                end
                ...
                defp process_message(todo_list, {:add_entry, new_entry}) do
                    TodoList.add_entry(todo_list, new_entry)
                end
            
            Concurrent vs Functional Approach
                You will find that in the end you will want to have a separate server for each of the instances of a data structure. That way you will be able to keep them Concurrent and be able to scale. Think of it this way you should try to model the changes to the data as a functional approach while the overlying state should be done with processes.

        5.3.5 Registered Processes
            In order to talk to an other process you will need to know the PID, so in order for process A to talk to Process B you will need to bring the PID for B to process A.

             For this there is a special function under the Process module Process.register(pid, name)
                The name can only be an atom
                a single process can have only 1 name
                two processe can not have the same name

            Look at the Chapter5 for the livebook to see the implementations for this type of function.
            Couple things to go over here. The Process.register(self(), :name) must be done before you spawn a new process within the start, once that is done you no longer need to pass the PID but simply pass the :name. 

            If you need to kill a process you can use:
                Process.whereis(:todo_server) |> Process.exit(:kill)

            Once you start a server you will need to not try and start it again as it will have an issue with the name already being taken. While in live book I used this logic to keep it from freaking out.
                def start do
                    spawn(fn ->
                    # Only register if not already taken
                    unless Process.whereis(:todo_server) do
                        Process.register(self(), :todo_server)
                    end

                    loop(TodoList.new())
                    end)
                end
    
    5.4 Runtime Considerations
        Let's talk about runtime properties
        
        5.4.1 A Process is Sequential
            Looking at the example you can see that you will be able to spawn the process to send messages but the single server will run into issues send responses. You can see if the number of servers was very high you would have a bottle neck. What can you do? try to optimize the response times for the single response server.

        5.4.2 Unlimited Process Mailboxes
            No lets think about the idea that a mailbox will continue to grow if the messages are not recieved or pattern matched correctly. (YOu should always have a default pattern match).

            defp loop
            receive do
                {:message, msg} -> do_something(msg)
                # add this to pattern match a default other -> warn_about_unknown_message(other)
            end
                loop()
            end

        5.4.3 Shared-Nothing Concurrency
            Nothing is shared between processes. So when you send a message the entire thing is deep copied.

        5.4.4 Scheduler Inner Workings
            Most of the time you will have n processes and m tasks run by the n process in most cases m > n this called m:n threading. 

            You will normally run process equal to the number of cores on your system but that can be changed with 
                iex --erl "put Erlang emulator flags here"

                $ iex --erl "+S 1"
                Erlang/OTP 26 [erts-14.0] [source] [64-bit] [smp:1:1] [ds:1:1:10]

                iex(1)> System.schedulers()
                1

    Summary
     A BEAM process is a lightweight concurrent unit of execution. Processes are
    completely isolated and share no memory.
     Processes can communicate with asynchronous messages. Synchronous sends
    and responses are manually built on top of this basic mechanism.
     A server process is a process that runs for a long time (possibly forever) and
    handles various messages. Server processes are powered by endless recursion.
     Server processes can maintain their own private state, using the arguments of
    endless recursion.

Chapter 6 Generic Server Processes (173)
    Let's learn about OTP (Open Telcecom Platform)
    
    6.1 Building a Generic Server Process
        Here we want to:
            spawn a separate process
            Run an infinite Loops
            Maintain a process state
            react to messages
            send a response back to the caller

        6.1.1 Plugging in with modules
            Generic code vs the concrete version you will end up with. In order to do this you will use modules. Remember that a module name is an atom and as such you can bind it to a variable and use the variable to call it.

            some_module = IO
            some_module.puts("hello")

        6.1.2 Implemeting the Generic Code
            With the code in the livebook Chapter_6 we have the star that will use the init. 
            then start the loop
            the return value of the spawn will be a pid.

            With the loop implemente we can go over it.
                The loop waits for a message of the format {request, caller}
                Then sends the response to the caller
                then restarts the loop.

            Now we need to be able to send a request to the server (as a user they will need to use a call/2 function). We use call in this case as we want to recieve a response.
        
        6.1.3 Using the Generic Abstration
            Now that we have the server setup you want to be able to have a callback function that will handle the data that we send and recieve.

            Now we can further obfiscate the process by adding in more helper functions. We are trying to remove the user knowing anything about the server. In this case we want to only have the KeyValueStore as the user interface. 

            Now we can use start/0 put/3 and get/2
                KeyValueStore.start()/0
                So the KeyValueStore will start a new Process
                
                Then the KeyValueStore.put()/3:
                will call ServerProcess.call()
                Then it will send a call to ServerProcess that will be of the form {request, caller(self())}
                The loop will recive that and send the request to the KeyValueStore using handle_call()/2
                It will process the :put from the list of handle call
                Which will {:ok, Map.put}
                
                Then when we use the KeyValueStore.get()/2:
                invoking the get from KeyValueStore
                which calls the ServerProcess PID with {:get, key}
                which sends the request (:get) to the ServerProcess
                The loop takes over and then sends that request (:get) to the callback function
                which then will {Map.get(state, key), state}

        6.1.4 Supporting asynchronous Requests
            Call is used for Synchronous requests as it wants a response, cast is used when we don't need a response.
            We added an extra bit to the send message and the call as now we need to be able to handle a call or a cast

        6.1.5 Exercise: Refactoring the Todo-Server
            Okay so let's go over this as it was abit of a strugle to figure this whole thing out. 
            First we wanted to start a ServerProcess with the TodoServer

            Second we needed to create 2 functions that will do the work for each action that we want handled.
            get() (entries)
                this will make the call to the Server that will ask for the entries that match the date.
            handle_call ({:entries, date}, state) 
                This will actually take the todo_list and perform the action

            put() (add_entries)
                This will make the call to the server that will do the work on the state
            handle_cast({:add_entries, entries}, state)
                This will actually perform the action to the state and update it.

            We wanted to keep as much of the underlying support awawy from the user so we need helper functions for each step
    
    6.2 Using GenServer
        180